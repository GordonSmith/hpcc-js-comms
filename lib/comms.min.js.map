{"version":3,"file":"comms.min.js","sources":["../src/util/string.ts","../src/comms/xhr.ts","../src/comms/index.ts","../src/util/SAXParser.ts","../src/esp/comms/transport.ts","../src/util/hashSum.ts","../src/util/object.ts","../src/esp/ecl/Graph.ts","../src/util/esp.ts","../src/util/runtime.ts","../src/comms/transport.ts","../src/comms/jsonp.ts","../src/collections/stack.ts","../src/esp/services/WsWorkunits.ts","../src/esp/services/WsTopology.ts","../src/esp/services/WsSMC.ts","../src/esp/services/WsDFU.ts","../src/util/observer.ts","../src/collections/stateful.ts","../src/util/Logging.ts","../src/esp/ecl/Resource.ts","../src/esp/ecl/Result.ts","../src/esp/ecl/SourceFile.ts","../src/esp/ecl/Timer.ts","../src/esp/ecl/Workunit.ts","../src/index.ts","../src/index-node.ts"],"sourcesContent":["export function endsWith(origString: string, searchString: string, position?: number) {\r\n    const subjectString = origString.toString();\r\n    if (typeof position !== \"number\" || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {\r\n        position = subjectString.length;\r\n    }\r\n    position -= searchString.length;\r\n    const lastIndex = subjectString.lastIndexOf(searchString, position);\r\n    return lastIndex !== -1 && lastIndex === position;\r\n}\r\n","import { ITransport, ResponseType, Transport } from \"./transport\";\r\n\r\nexport { ITransport } from \"./transport\";\r\n\r\nlet _nodeRequest = null;\r\nexport function initNodeRequest(request) {\r\n    _nodeRequest = request;\r\n}\r\n\r\nlet _d3Request = null;\r\nexport function initD3Request(request) {\r\n    _d3Request = request;\r\n}\r\n\r\nexport class XHRTransport extends Transport implements ITransport {\r\n    timeout: number;\r\n    verb: \"GET\" | \"POST\";\r\n    userID: string;\r\n    password: string;\r\n    rejectUnauthorized: boolean;\r\n\r\n    constructor(baseUrl: string, verb: \"GET\" | \"POST\", userID: string = \"\", password: string = \"\", rejectUnauthorized: boolean = true) {\r\n        super(baseUrl);\r\n        this.verb = verb;\r\n        this.userID = userID;\r\n        this.password = password;\r\n        this.rejectUnauthorized = rejectUnauthorized;\r\n    }\r\n\r\n    private nodeRequestSend(action: string, request: any, responseType: ResponseType = \"json\"): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            const options: any = {\r\n                method: this.verb,\r\n                uri: this.joinUrl(action),\r\n                auth: {\r\n                    user: this.userID,\r\n                    pass: this.password,\r\n                    sendImmediately: true\r\n                },\r\n                username: this.userID,\r\n                password: this.password\r\n            };\r\n            switch (this.verb) {\r\n                case \"GET\":\r\n                    options.uri += \"?\" + this.serialize(request);\r\n                    break;\r\n                case \"POST\":\r\n                    options.headers = {\r\n                        \"X-Requested-With\": \"XMLHttpRequest\",\r\n                        \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n                    };\r\n                    options.rejectUnauthorized = this.rejectUnauthorized;\r\n                    options.body = this.serialize(request);\r\n                    break;\r\n                default:\r\n            }\r\n            _nodeRequest(options, (err, resp, body) => {\r\n                if (err) {\r\n                    reject(new Error(err));\r\n                } else if (resp && resp.statusCode === 200) {\r\n                    resolve(responseType === \"json\" ? this.deserialize(body) : body);\r\n                } else {\r\n                    reject(new Error(body));\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    private d3Send(action: string, request: any, responseType: ResponseType = \"json\"): Promise<any> {\r\n        return new Promise((resolve, reject) => {\r\n            const options: any = {\r\n                method: this.verb,\r\n                uri: this.joinUrl(action),\r\n                auth: {\r\n                    user: this.userID,\r\n                    pass: this.password,\r\n                    sendImmediately: true\r\n                },\r\n                username: this.userID,\r\n                password: this.password\r\n            };\r\n            switch (this.verb) {\r\n                case \"GET\":\r\n                    options.uri += \"?\" + this.serialize(request);\r\n                    break;\r\n                case \"POST\":\r\n                    options.headers = {\r\n                        \"X-Requested-With\": \"XMLHttpRequest\",\r\n                        \"Content-Type\": \"application/x-www-form-urlencoded\"\r\n                    };\r\n                    options.rejectUnauthorized = this.rejectUnauthorized;\r\n                    options.body = this.serialize(request);\r\n                    break;\r\n                default:\r\n            }\r\n            const xhr = _d3Request(options.uri);\r\n            if (this.verb === \"POST\") {\r\n                xhr\r\n                    .header(\"X-Requested-With\", \"XMLHttpRequest\")\r\n                    .header(\"Content-Type\", \"application/x-www-form-urlencoded\")\r\n                    .header(\"Origin\", null)\r\n                    ;\r\n            }\r\n            xhr\r\n                .send(this.verb, options.body, (err, req) => {\r\n                    if (err) {\r\n                        reject(new Error(err));\r\n                    } else if (req && req.status === 200) {\r\n                        resolve(responseType === \"json\" ? this.deserialize(req.responseText) : req.responseText);\r\n                    } else {\r\n                        reject(new Error(req.responseText));\r\n                    }\r\n                });\r\n        });\r\n    }\r\n\r\n    send(action: string, request: any, responseType: ResponseType = \"json\"): Promise<any> {\r\n        if (_nodeRequest) {\r\n            return this.nodeRequestSend(action, request, responseType);\r\n        } else if (_d3Request) {\r\n            return this.d3Send(action, request, responseType);\r\n        }\r\n        throw new Error(\"No transport\");\r\n    }\r\n}\r\n\r\nexport class XHRGetTransport extends XHRTransport implements ITransport {\r\n    constructor(baseUrl: string, userID: string = \"\", password: string = \"\", rejectUnauthorized: boolean = true) {\r\n        super(baseUrl, \"GET\", userID, password, rejectUnauthorized);\r\n    }\r\n}\r\nexport class XHRPostTransport extends XHRTransport implements ITransport {\r\n    constructor(baseUrl, userID: string = \"\", password: string = \"\", rejectUnauthorized: boolean = true) {\r\n        super(baseUrl, \"POST\", userID, password, rejectUnauthorized);\r\n    }\r\n}\r\n","import { JSONPTransport } from \"./jsonp\";\r\nimport { ITransport, TransportOptions } from \"./transport\";\r\nimport { XHRGetTransport, XHRPostTransport } from \"./xhr\";\r\n\r\nexport {\r\n    ITransport,\r\n    JSONPTransport,\r\n    XHRPostTransport,\r\n    XHRGetTransport\r\n};\r\n\r\nexport type ITransportFactory = (baseUrl: string) => ITransport;\r\nexport let createTransport: ITransportFactory = function (baseUrl: string, opts?: TransportOptions): ITransport {\r\n    const retVal = new XHRPostTransport(baseUrl);\r\n    if (opts) {\r\n        retVal.opts(opts);\r\n    }\r\n    return retVal;\r\n};\r\n\r\nexport function setTransportFactory(newFunc: ITransportFactory): ITransportFactory {\r\n    const retVal = createTransport;\r\n    createTransport = newFunc;\r\n    return retVal;\r\n}\r\n","import { Stack } from \"../collections/stack\";\r\n// import { DOMParser } from \"../platform/node\";\r\n\r\nexport type PrimativeValue = string;\r\nexport type PrimativeValueMap = { [key: string]: PrimativeValue };\r\nexport class XMLNode {\r\n    name: string = \"\";\r\n    attributes: PrimativeValueMap = {};\r\n    children: XMLNode[] = [];\r\n    content: string = \"\";\r\n\r\n    constructor(node) {\r\n        this.name = node.name;\r\n    }\r\n\r\n    appendAttribute(key: string, val: string) {\r\n        this.attributes[key] = val;\r\n    }\r\n\r\n    appendContent(content: string) {\r\n        this.content += content;\r\n    }\r\n\r\n    appendChild(child: XMLNode) {\r\n        this.children.push(child);\r\n    }\r\n}\r\n\r\nexport class SAXStackParser {\r\n    root: XMLNode;\r\n    stack: Stack<XMLNode> = new Stack<XMLNode>();\r\n\r\n    constructor() {\r\n    }\r\n\r\n    private walkDoc(node: Node) {\r\n        this.startXMLNode({\r\n            name: node.nodeName\r\n        });\r\n        if (node.attributes) {\r\n            for (let i = 0; i < node.attributes.length; ++i) {\r\n                const attribute = node.attributes.item(i);\r\n                this.attributes(attribute.nodeName, attribute.nodeValue);\r\n            }\r\n        }\r\n        if (node.childNodes) {\r\n            for (let i = 0; i < node.childNodes.length; ++i) {\r\n                const childNode = node.childNodes.item(i);\r\n                if (childNode.nodeType === childNode.TEXT_NODE) {\r\n                    this.characters(childNode.nodeValue);\r\n                } else {\r\n                    this.walkDoc(childNode);\r\n                }\r\n            }\r\n        }\r\n        this.endXMLNode({\r\n            name: node.nodeName\r\n        });\r\n    }\r\n\r\n    parse(xml: string) {\r\n        const domParser = new DOMParser();\r\n        const doc = domParser.parseFromString(xml, \"application/xml\");\r\n        this.startDocument();\r\n        this.walkDoc(doc);\r\n        this.endDocument();\r\n    }\r\n\r\n    //  Callbacks  ---\r\n    startDocument() {\r\n    }\r\n\r\n    endDocument() {\r\n    }\r\n\r\n    startXMLNode(node): XMLNode {\r\n        const newNode = new XMLNode(node);\r\n        if (!this.stack.depth()) {\r\n            this.root = newNode;\r\n        } else {\r\n            this.stack.top().appendChild(newNode);\r\n        }\r\n        return this.stack.push(newNode);\r\n    }\r\n\r\n    endXMLNode(_): XMLNode {\r\n        return this.stack.pop();\r\n    }\r\n\r\n    attributes(key, val) {\r\n        this.stack.top().appendAttribute(key, val);\r\n    }\r\n\r\n    characters(text) {\r\n        this.stack.top().appendContent(text);\r\n    }\r\n}\r\n\r\nexport function xml2json(xml): XMLNode {\r\n    const saxParser = new SAXStackParser();\r\n    saxParser.parse(xml);\r\n    return saxParser.root;\r\n}\r\n\r\nexport class XSDNode {\r\n    protected e?: XMLNode;\r\n\r\n    constructor(e: XMLNode) {\r\n        this.e = e;\r\n    }\r\n    fix() {\r\n        delete this.e;\r\n    }\r\n}\r\n\r\nexport class XSDXMLNode extends XSDNode {\r\n    name: string;\r\n    type: string;\r\n    private children: XSDXMLNode[] = [];\r\n\r\n    constructor(e: XMLNode) {\r\n        super(e);\r\n    }\r\n\r\n    append(child: XSDXMLNode) {\r\n        this.children.push(child);\r\n    }\r\n\r\n    fix() {\r\n        this.name = this.e.attributes[\"name\"];\r\n        this.type = this.e.attributes[\"type\"];\r\n        for (let i = this.children.length - 1; i >= 0; --i) {\r\n            const row = this.children[i];\r\n            if (row.name === \"Row\" && row.type === undefined) {\r\n                this.children.push(...row.children);\r\n                this.children.splice(i, 1);\r\n            }\r\n        }\r\n        super.fix();\r\n    }\r\n}\r\n\r\nexport class XSDSimpleType extends XSDNode {\r\n    name: string;\r\n    type: string;\r\n    maxLength: number;\r\n\r\n    protected _restricition?: XMLNode;\r\n    protected _maxLength?: XMLNode;\r\n\r\n    constructor(e: XMLNode) {\r\n        super(e);\r\n    }\r\n\r\n    append(e: XMLNode) {\r\n        switch (e.name) {\r\n            case \"xs:restriction\":\r\n                this._restricition = e;\r\n                break;\r\n            case \"xs:maxLength\":\r\n                this._maxLength = e;\r\n                break;\r\n            default:\r\n        }\r\n    }\r\n\r\n    fix() {\r\n        this.name = this.e.attributes[\"name\"];\r\n        this.type = this._restricition.attributes[\"base\"];\r\n        this.maxLength = +this._maxLength.attributes[\"value\"];\r\n        delete this._restricition;\r\n        delete this._maxLength;\r\n        super.fix();\r\n    }\r\n}\r\n\r\nexport class XSDSchema {\r\n    root: XSDXMLNode;\r\n    simpleTypes: { [name: string]: XSDSimpleType } = {};\r\n\r\n    calcWidth(type, name) {\r\n        let retVal: number = -1;\r\n\r\n        switch (type) {\r\n            case \"xs:boolean\":\r\n                retVal = 5;\r\n                break;\r\n            case \"xs:integer\":\r\n                retVal = 8;\r\n                break;\r\n            case \"xs:nonNegativeInteger\":\r\n                retVal = 8;\r\n                break;\r\n            case \"xs:double\":\r\n                retVal = 8;\r\n                break;\r\n            case \"xs:string\":\r\n                retVal = 32;\r\n                break;\r\n            default:\r\n                const numStr: string = \"0123456789\";\r\n                const underbarPos: number = type.lastIndexOf(\"_\");\r\n                const length: number = underbarPos > 0 ? underbarPos : type.length;\r\n                let i: number = length - 1;\r\n                for (; i >= 0; --i) {\r\n                    if (numStr.indexOf(type.charAt(i)) === -1)\r\n                        break;\r\n                }\r\n                if (i + 1 < length) {\r\n                    retVal = parseInt(type.substring(i + 1, length), 10);\r\n                }\r\n                if (type.indexOf(\"data\") === 0) {\r\n                    retVal *= 2;\r\n                }\r\n                break;\r\n        }\r\n        if (retVal < name.length)\r\n            retVal = name.length;\r\n\r\n        return retVal;\r\n    }\r\n}\r\n\r\nclass XSDParser extends SAXStackParser {\r\n    schema: XSDSchema = new XSDSchema();\r\n    simpleType: XSDSimpleType;\r\n    simpleTypes: { [name: string]: XSDSimpleType } = {};\r\n\r\n    xsdStack: Stack<XSDXMLNode> = new Stack<XSDXMLNode>();\r\n\r\n    startXMLNode(node): XMLNode {\r\n        const e = super.startXMLNode(node);\r\n        switch (e.name) {\r\n            case \"xs:element\":\r\n                const xsdXMLNode = new XSDXMLNode(e);\r\n                if (!this.schema.root) {\r\n                    this.schema.root = xsdXMLNode;\r\n                } else if (this.xsdStack.depth()) {\r\n                    this.xsdStack.top().append(xsdXMLNode);\r\n                }\r\n                this.xsdStack.push(xsdXMLNode);\r\n                break;\r\n            case \"xs:simpleType\":\r\n                this.simpleType = new XSDSimpleType(e);\r\n            default:\r\n                break;\r\n        }\r\n        return e;\r\n    }\r\n\r\n    endXMLNode(node): XMLNode {\r\n        const e = this.stack.top();\r\n        switch (e.name) {\r\n            case \"xs:element\":\r\n                const xsdXMLNode = this.xsdStack.pop();\r\n                xsdXMLNode.fix();\r\n                break;\r\n            case \"xs:simpleType\":\r\n                this.simpleType.fix();\r\n                this.simpleTypes[this.simpleType.name] = this.simpleType;\r\n                delete this.simpleType;\r\n                break;\r\n            default:\r\n                if (this.simpleType) {\r\n                    this.simpleType.append(e);\r\n                }\r\n        }\r\n        return super.endXMLNode(node);\r\n    }\r\n}\r\n\r\nexport function parseXSD(xml): XSDSchema {\r\n    const saxParser = new XSDParser();\r\n    saxParser.parse(xml);\r\n    return saxParser.schema;\r\n}\r\n","import { ITransport, ResponseType, Transport } from \"../../comms/transport\";\r\n\r\nexport function isArray(arg: any) {\r\n    return Object.prototype.toString.call(arg) === \"[object Array]\";\r\n};\r\n\r\nexport interface Exception {\r\n    Code: number;\r\n    Message: string;\r\n}\r\n\r\nexport interface Exceptions {\r\n    Source: string;\r\n    Exception: Exception[];\r\n}\r\n\r\nexport class ESPExceptions extends Error implements Exceptions {\r\n    readonly isESPExceptions = true;\r\n    action: string;\r\n    request: string;\r\n    Source: string;\r\n    Exception: Exception[];\r\n\r\n    constructor(action: string, request: any, exceptions: Exceptions) {\r\n        super(\"ESPException:  \" + exceptions.Source);\r\n        this.action = action;\r\n        this.request = request;\r\n        this.Source = exceptions.Source;\r\n        this.Exception = exceptions.Exception;\r\n    }\r\n}\r\n\r\nexport class ESPTransport extends Transport {\r\n    private _transport: ITransport;\r\n    private _service: string;\r\n    private _version: string;\r\n\r\n    constructor(transport: ITransport, service: string, version: string) {\r\n        super(\"\");\r\n        this._transport = transport;\r\n        this._service = service;\r\n        this._version = version;\r\n    }\r\n\r\n    toESPStringArray(target: any, arrayName: string): Object {\r\n        if (isArray(target[arrayName])) {\r\n            for (let i = 0; i < target[arrayName].length; ++i) {\r\n                target[arrayName + \"_i\" + i] = target[arrayName][i];\r\n            }\r\n            delete target[arrayName];\r\n        }\r\n        return target;\r\n    }\r\n\r\n    send(action: string, _request: any = {}, responseType: ResponseType = \"json\"): Promise<any> {\r\n        const request = { ..._request, ...{ ver_: this._version } };\r\n        const serviceAction = this.joinUrl(this._service, action + \".json\");\r\n        return this._transport.send(serviceAction, request, responseType).then((response) => {\r\n            if (responseType === \"json\") {\r\n                if (response.Exceptions) {\r\n                    throw new ESPExceptions(action, request, response.Exceptions);\r\n                }\r\n                const retVal = response[`${action === \"WUCDebug\" ? \"WUDebug\" : action}Response`];\r\n                if (!retVal) {\r\n                    throw new ESPExceptions(action, request, {\r\n                        Source: \"ESPConnection.transmit\",\r\n                        Exception: [{ Code: 0, Message: \"Missing Response\" }]\r\n                    });\r\n                }\r\n                return retVal;\r\n            }\r\n            return response;\r\n        });\r\n    }\r\n}\r\n","//  Ported to TypeScript from:  https://github.com/bevacqua/hash-sum\r\n\r\nfunction pad(hash: string, len: number): string {\r\n    while (hash.length < len) {\r\n        hash = \"0\" + hash;\r\n    }\r\n    return hash;\r\n}\r\n\r\nfunction fold(hash: number, text: string): number {\r\n    if (text.length === 0) {\r\n        return hash;\r\n    }\r\n    for (let i = 0; i < text.length; ++i) {\r\n        const chr = text.charCodeAt(i);\r\n        // tslint:disable:no-bitwise\r\n        hash = ((hash << 5) - hash) + chr;\r\n        hash |= 0;\r\n        // tslint:enable:no-bitwise\r\n    }\r\n    return hash < 0 ? hash * -2 : hash;\r\n}\r\n\r\nfunction foldObject(hash: number, o: object, seen: any[]) {\r\n    return Object.keys(o).sort().reduce((input: any, key: string) => {\r\n        return foldValue(input, o[key], key, seen);\r\n    }, hash);\r\n}\r\n\r\nfunction foldValue(input: number, value: any, key: string, seen: any[]) {\r\n    const hash = fold(fold(fold(input, key), toString(value)), typeof value);\r\n    if (value === null) {\r\n        return fold(hash, \"null\");\r\n    }\r\n    if (value === undefined) {\r\n        return fold(hash, \"undefined\");\r\n    }\r\n    if (typeof value === \"object\") {\r\n        if (seen.indexOf(value) !== -1) {\r\n            return fold(hash, \"[Circular]\" + key);\r\n        }\r\n        seen.push(value);\r\n        return foldObject(hash, value, seen);\r\n    }\r\n    return fold(hash, value.toString());\r\n}\r\n\r\nfunction toString(o: object): string {\r\n    return Object.prototype.toString.call(o);\r\n}\r\n\r\nexport function hashSum(o: any): string {\r\n    return pad(foldValue(0, o, \"\", []).toString(16), 8);\r\n}\r\n","/**\r\n * inner - return inner property of Object\r\n * Usage:  inner(\"some.prop.to.locate\", obj);\r\n *\r\n * @param prop - property to locate\r\n * @param obj - object to locate property in\r\n */\r\nexport function inner(prop: string, obj: any): any {\r\n    if (prop === void 0 || obj === void 0) return void 0;\r\n    for (const item of prop.split(\".\")) {\r\n        if (!obj.hasOwnProperty(item)) {\r\n            return undefined;\r\n        }\r\n        obj = obj[item];\r\n    }\r\n    return obj;\r\n}\r\n\r\n/**\r\n * exists - return inner property of Object\r\n * Usage:  inner(\"some.prop.to.locate\", obj);\r\n *\r\n * @param prop - property to locate\r\n * @param obj - object to locate property in\r\n */\r\nexport function exists(prop: string, obj: Object): boolean {\r\n    return inner(prop, obj) !== undefined;\r\n};\r\n","import { Cache, StateObject } from \"../../collections/stateful\";\r\nimport { PrimativeValueMap, XMLNode } from \"../../util/SAXParser\";\r\nimport { ECLGraph, Service } from \"../services/WsWorkunits\";\r\nimport { Timer } from \"./Timer\";\r\n\r\nexport interface ECLGraphEx extends ECLGraph {\r\n    Wuid: string;\r\n    Time: number;\r\n}\r\nexport class Graph extends StateObject<ECLGraphEx, ECLGraphEx> implements ECLGraphEx {\r\n    protected connection: Service;\r\n\r\n    get properties(): ECLGraphEx { return this.get(); }\r\n    get Wuid(): string { return this.get(\"Wuid\"); }\r\n    get Name(): string { return this.get(\"Name\"); }\r\n    get Label(): string { return this.get(\"Label\"); }\r\n    get Type(): string { return this.get(\"Type\"); }\r\n    get Complete(): boolean { return this.get(\"Complete\"); }\r\n    get WhenStarted(): Date { return this.get(\"WhenStarted\"); }\r\n    get WhenFinished(): Date { return this.get(\"WhenFinished\"); }\r\n    get Time(): number { return this.get(\"Time\"); }\r\n\r\n    constructor(connection: Service | string, wuid: string, eclGraph: ECLGraph, eclTimers: Timer[]) {\r\n        super();\r\n        if (connection instanceof Service) {\r\n            this.connection = connection;\r\n        } else {\r\n            this.connection = new Service(connection);\r\n        }\r\n        let duration = 0;\r\n        for (const eclTimer of eclTimers) {\r\n            if (eclTimer.GraphName === eclGraph.Name && !eclTimer.HasSubGraphId) {\r\n                duration = Math.round(eclTimer.Seconds * 1000) / 1000;\r\n                break;\r\n            }\r\n        }\r\n        this.set({ Wuid: wuid, Time: duration, ...eclGraph });\r\n    }\r\n}\r\n\r\nexport class GraphCache extends Cache<ECLGraph, Graph> {\r\n    constructor() {\r\n        super((obj) => {\r\n            return Cache.hash([obj.Name]);\r\n        });\r\n    }\r\n}\r\n\r\n//  XGMML Graph ---\r\n\r\nconst ATTR_DEFINITION = \"definition\";\r\n\r\nexport interface IECLDefintion {\r\n    id: string;\r\n    file: string;\r\n    line: number;\r\n    column: number;\r\n}\r\n\r\nexport class GraphItem {\r\n    parent: Subgraph;\r\n    id: string;\r\n    attrs: PrimativeValueMap;\r\n    constructor(parent: Subgraph, id: string, attrs: PrimativeValueMap) {\r\n        this.parent = parent;\r\n        this.id = id;\r\n        this.attrs = attrs;\r\n    }\r\n\r\n    className(): \"XGMMLGraph\" | \"Subgraph\" | \"Vertex\" | \"Edge\" {\r\n        return (<any>this.constructor).name;\r\n    }\r\n\r\n    hasECLDefinition(): boolean {\r\n        return this.attrs[ATTR_DEFINITION] !== undefined;\r\n    }\r\n\r\n    getECLDefinition(): IECLDefintion {\r\n        const match = /([a-z]:\\\\(?:[-\\w\\.\\d]+\\\\)*(?:[-\\w\\.\\d]+)?|(?:\\/[\\w\\.\\-]+)+)\\((\\d*),(\\d*)\\)/.exec(this.attrs[ATTR_DEFINITION]);\r\n        if (match) {\r\n            const [, _file, _row, _col] = match;\r\n            _file.replace(\"/./\", \"/\");\r\n            return {\r\n                id: this.id,\r\n                file: _file,\r\n                line: +_row,\r\n                column: +_col\r\n            };\r\n        }\r\n        throw `Bad definition:  ${this.attrs[ATTR_DEFINITION]}`;\r\n    }\r\n}\r\n\r\nexport class Subgraph extends GraphItem {\r\n    subgraphs: Subgraph[] = [];\r\n    subgraphsMap: { [key: string]: Subgraph } = {};\r\n    vertices: Vertex[] = [];\r\n    verticesMap: { [key: string]: Vertex } = {};\r\n    edges: Edge[] = [];\r\n    edgesMap: { [key: string]: Edge } = {};\r\n\r\n    constructor(parent: Subgraph, id: string, attrs: PrimativeValueMap) {\r\n        super(parent, id, attrs);\r\n        if (parent) {  //  Only needed for root node\r\n            parent.addSubgraph(this);\r\n        }\r\n    }\r\n\r\n    addSubgraph(subgraph: Subgraph) {\r\n        if (this.subgraphsMap[subgraph.id] !== undefined) {\r\n            throw \"Subgraph already exists\";\r\n        }\r\n        this.subgraphsMap[subgraph.id] = subgraph;\r\n        this.subgraphs.push(subgraph);\r\n    }\r\n\r\n    addVertex(vertex: Vertex) {\r\n        if (this.verticesMap[vertex.id] !== undefined) {\r\n            throw \"Vertex already exists\";\r\n        }\r\n        this.verticesMap[vertex.id] = vertex;\r\n        this.vertices.push(vertex);\r\n    }\r\n\r\n    addEdge(edge: Edge) {\r\n        if (this.edgesMap[edge.id] !== undefined) {\r\n            throw \"Edge already exists\";\r\n        }\r\n        this.edgesMap[edge.id] = edge;\r\n        this.edges.push(edge);\r\n    }\r\n\r\n    getNearestDefinition(backwards: boolean = true): IECLDefintion {\r\n        if (this.hasECLDefinition()) {\r\n            return this.getECLDefinition();\r\n        }\r\n        if (backwards) {\r\n            for (let i = this.vertices.length - 1; i >= 0; --i) {\r\n                const vertex = this.vertices[i];\r\n                if (vertex.hasECLDefinition()) {\r\n                    return vertex.getECLDefinition();\r\n                }\r\n            }\r\n        }\r\n        let retVal: IECLDefintion;\r\n        this.vertices.some((vertex) => {\r\n            retVal = vertex.getNearestDefinition();\r\n            if (retVal) {\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return retVal;\r\n    }\r\n}\r\n\r\nexport class Vertex extends GraphItem {\r\n    label: string;\r\n    inEdges: Edge[] = [];\r\n    outEdges: Edge[] = [];\r\n\r\n    constructor(parent: Subgraph, id: string, label: string, attrs: PrimativeValueMap) {\r\n        super(parent, id, attrs);\r\n        this.label = label;\r\n        parent.addVertex(this);\r\n    }\r\n\r\n    getNearestDefinition(): IECLDefintion {\r\n        if (this.hasECLDefinition()) {\r\n            return this.getECLDefinition();\r\n        }\r\n        let retVal: IECLDefintion;\r\n        this.inEdges.some((edge) => {\r\n            retVal = edge.getNearestDefinition();\r\n            if (retVal) {\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        return retVal;\r\n    }\r\n}\r\n\r\nexport class XGMMLGraph extends Subgraph {\r\n    allSubgraphs: { [key: string]: Subgraph } = {};\r\n    allVertices: { [key: string]: Vertex } = {};\r\n    allEdges: { [key: string]: Edge } = {};\r\n\r\n    constructor(id: string) {\r\n        super(null, id, {});\r\n    }\r\n\r\n    breakpointLocations(path?): IECLDefintion[] {\r\n        const retVal: IECLDefintion[] = [];\r\n        for (const key in this.allVertices) {\r\n            if (this.allVertices.hasOwnProperty(key)) {\r\n                const vertex = this.allVertices[key];\r\n                if (vertex.hasECLDefinition()) {\r\n                    const definition = vertex.getECLDefinition();\r\n                    if (definition && !path || path === definition.file) {\r\n                        retVal.push(definition);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return retVal.sort((l, r) => {\r\n            return l.line - r.line;\r\n        });\r\n    }\r\n}\r\n\r\nexport class Edge extends Subgraph {\r\n    sourceID: string;\r\n    source: Vertex;\r\n    targetID: string;\r\n    target: Vertex;\r\n\r\n    constructor(parent: Subgraph, id: string, sourceID: string, targetID: string, attrs: PrimativeValueMap) {\r\n        super(parent, id, attrs);\r\n        this.sourceID = sourceID;\r\n        this.targetID = targetID;\r\n        parent.addEdge(this);\r\n    }\r\n\r\n    getNearestDefinition(): IECLDefintion {\r\n        if (this.hasECLDefinition()) {\r\n            return this.getECLDefinition();\r\n        }\r\n        return this.source.getNearestDefinition();\r\n    }\r\n}\r\n\r\ntype Callback = (tag: string, attributes: PrimativeValueMap, children: XMLNode[], _stack) => void;\r\nfunction walkXmlJson(node: XMLNode, callback: Callback, stack?: XMLNode[]) {\r\n    stack = stack || [];\r\n    stack.push(node);\r\n    callback(node.name, node.attributes, node.children, stack);\r\n    node.children.forEach((childNode) => {\r\n        walkXmlJson(childNode, callback, stack);\r\n    });\r\n    stack.pop();\r\n}\r\n\r\nfunction flattenAtt(nodes: XMLNode[]): PrimativeValueMap {\r\n    const retVal: PrimativeValueMap = {};\r\n    nodes.forEach((node: XMLNode) => {\r\n        if (node.name === \"att\") {\r\n            retVal[node.attributes[\"name\"]] = node.attributes[\"value\"];\r\n        }\r\n    });\r\n    return retVal;\r\n}\r\n\r\nexport function createXGMMLGraph(id, graphs: XMLNode): XGMMLGraph {\r\n    const graph = new XGMMLGraph(id);\r\n    const stack: Subgraph[] = [graph];\r\n    walkXmlJson(graphs, (tag: string, attributes: PrimativeValueMap, children: XMLNode[], _stack) => {\r\n        const top = stack[stack.length - 1];\r\n        switch (tag) {\r\n            case \"graph\":\r\n                break;\r\n            case \"node\":\r\n                if (children.length && children[0].children.length && children[0].children[0].name === \"graph\") {\r\n                    const subgraph = new Subgraph(top, `graph${attributes[\"id\"]}`, flattenAtt(children));\r\n                    graph.allSubgraphs[subgraph.id] = subgraph;\r\n                    stack.push(subgraph);\r\n                } else {\r\n                    const vertex = new Vertex(top, attributes[\"id\"], attributes[\"label\"], flattenAtt(children));\r\n                    graph.allVertices[vertex.id] = vertex;\r\n                }\r\n                break;\r\n            case \"edge\":\r\n                const edge = new Edge(top, attributes[\"id\"], attributes[\"source\"], attributes[\"target\"], flattenAtt(children));\r\n                graph.allEdges[edge.id] = edge;\r\n                break;\r\n            default:\r\n        }\r\n    });\r\n    for (const key in graph.allEdges) {\r\n        if (graph.allEdges.hasOwnProperty(key)) {\r\n            const edge = graph.allEdges[key];\r\n            try {\r\n                edge.source = graph.allVertices[edge.sourceID];\r\n                edge.target = graph.allVertices[edge.targetID];\r\n                edge.source.outEdges.push(edge);\r\n                edge.target.inEdges.push(edge);\r\n            } catch (e) { }\r\n        }\r\n    }\r\n    return graph;\r\n}\r\n","export function espTime2Seconds(duration) {\r\n    if (!duration) {\r\n        return 0;\r\n    } else if (!isNaN(duration)) {\r\n        return parseFloat(duration);\r\n    }\r\n    //  GH:  <n>ns or <m>ms or <s>s or [<d> days ][<h>:][<m>:]<s>[.<ms>]\r\n    const nsIndex = duration.indexOf(\"ns\");\r\n    if (nsIndex !== -1) {\r\n        return parseFloat(duration.substr(0, nsIndex)) / 1000000000;\r\n    }\r\n    const msIndex = duration.indexOf(\"ms\");\r\n    if (msIndex !== -1) {\r\n        return parseFloat(duration.substr(0, msIndex)) / 1000;\r\n    }\r\n    const sIndex = duration.indexOf(\"s\");\r\n    if (sIndex !== -1 && duration.indexOf(\"days\") === -1) {\r\n        return parseFloat(duration.substr(0, sIndex));\r\n    }\r\n\r\n    const dayTimeParts = duration.split(\" days \");\r\n    const days = parseFloat(dayTimeParts.length > 1 ? dayTimeParts[0] : 0.0);\r\n    const time = dayTimeParts.length > 1 ? dayTimeParts[1] : dayTimeParts[0];\r\n    let secs = 0.0;\r\n    const timeParts = time.split(\":\").reverse();\r\n    for (let j = 0; j < timeParts.length; ++j) {\r\n        secs += parseFloat(timeParts[j]) * Math.pow(60, j);\r\n    }\r\n    return (days * 24 * 60 * 60) + secs;\r\n}\r\n","export const root = new Function(\"try {return global;}catch(e){return window;}\")();\r\n\r\nexport const isBrowser = new Function(\"try {return this===window;}catch(e){ return false;}\");\r\nexport const isNode = new Function(\"try {return this===global;}catch(e){return false;}\");\r\nexport const isTravis = new Function(\"try {return process.env.TRAVIS ;}catch(e){return false;}\");\r\n","import { endsWith } from \"../util/string\";\r\n\r\nexport type ResponseType = \"json\" | \"text\";\r\n\r\nexport type TransportOptions = {\r\n    baseUrl: string,\r\n    userID?: string,\r\n    password?: string,\r\n    [key: string]: any\r\n};\r\nexport interface ITransport {\r\n    send(action: string, request: any, responseType?: ResponseType): Promise<any>;\r\n    opts(_: TransportOptions): this;\r\n    opts(): TransportOptions;\r\n}\r\n\r\nexport class Transport {\r\n    protected _opts: TransportOptions;\r\n\r\n    constructor(baseUrl: string) {\r\n        this.opts({ baseUrl });\r\n    }\r\n\r\n    opts(_: TransportOptions): this;\r\n    opts(): TransportOptions;\r\n    opts(_?: TransportOptions): this | TransportOptions {\r\n        if (arguments.length === 0) return this._opts;\r\n        this._opts = { ...this._opts, ..._ };\r\n        return this;\r\n    }\r\n\r\n    protected serialize(obj: any) {\r\n        const str: string[] = [];\r\n        for (const key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                str.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(obj[key]));\r\n            }\r\n        }\r\n        return str.join(\"&\");\r\n    }\r\n\r\n    deserialize(body: string) {\r\n        return JSON.parse(body);\r\n    }\r\n\r\n    stripSlashes(str: string) {\r\n        while (str.indexOf(\"/\") === 0) {\r\n            str = str.substring(1);\r\n        }\r\n        while (endsWith(str, \"/\")) {\r\n            str = str.substring(0, str.length - 1);\r\n        }\r\n        return str;\r\n    }\r\n\r\n    joinUrl(...args: string[]) {\r\n        return this.stripSlashes(this._opts.baseUrl) + \"/\" + args.map((arg) => {\r\n            return this.stripSlashes(arg);\r\n        }).join(\"/\");\r\n    }\r\n}\r\n","import { ITransport, Transport } from \"./transport\";\r\n\r\nexport class JSONPTransport extends Transport implements ITransport {\r\n    timeout: number;\r\n\r\n    constructor(baseUrl: string, timeout: number = 60) {\r\n        super(baseUrl);\r\n        this.timeout = timeout;\r\n    }\r\n\r\n    send(action: string, request: any): Promise<any> {\r\n        return new Promise<any>((resolve, reject) => {\r\n            let respondedTimeout = this.timeout * 1000;\r\n            const respondedTick = 5000;\r\n            const callbackName = \"jsonp_callback_\" + Math.round(Math.random() * 999999);\r\n            window[callbackName] = function (response) {\r\n                respondedTimeout = 0;\r\n                doCallback();\r\n                resolve(response);\r\n            };\r\n            const script = document.createElement(\"script\");\r\n            let url = this.joinUrl(action);\r\n            url += url.indexOf(\"?\") >= 0 ? \"&\" : \"?\";\r\n            script.src = url + \"jsonp=\" + callbackName + \"&\" + this.serialize(request);\r\n            document.body.appendChild(script);\r\n            const progress = setInterval(function () {\r\n                if (respondedTimeout <= 0) {\r\n                    clearInterval(progress);\r\n                } else {\r\n                    respondedTimeout -= respondedTick;\r\n                    if (respondedTimeout <= 0) {\r\n                        clearInterval(progress);\r\n                        // console.log(\"Request timeout:  \" + script.src);\r\n                        doCallback();\r\n                        reject(Error(\"Request timeout:  \" + script.src));\r\n                    } else {\r\n                        // console.log(\"Request pending (\" + respondedTimeout / 1000 + \" sec):  \" + script.src);\r\n                    }\r\n                }\r\n            }, respondedTick);\r\n\r\n            function doCallback() {\r\n                delete window[callbackName];\r\n                document.body.removeChild(script);\r\n            }\r\n        });\r\n    };\r\n}\r\n","/**\r\n * A generic Stack\r\n */\r\nexport class Stack<T> {\r\n    private stack: T[] = [];\r\n\r\n    /**\r\n     * Push element onto the stack\r\n     *\r\n     * @param e - element to push\r\n     */\r\n    push(e: T) {\r\n        this.stack.push(e);\r\n        return e;\r\n    }\r\n\r\n    /**\r\n     * Pop element off the stack\r\n     */\r\n    pop(): T | undefined {\r\n        return this.stack.pop();\r\n    }\r\n\r\n    /**\r\n     * Top item on the stack\r\n     *\r\n     * @returns Top element on the stack\r\n     */\r\n    top(): T | undefined {\r\n        return this.stack.length ? this.stack[this.stack.length - 1] : undefined;\r\n    }\r\n\r\n    /**\r\n     * Depth of stack\r\n     *\r\n     * @returns Depth\r\n     */\r\n    depth(): number {\r\n        return this.stack.length;\r\n    }\r\n}\r\n","import { createTransport, ITransport } from \"../../comms/index\";\r\nimport { xml2json, XMLNode } from \"../../util/SAXParser\";\r\nimport { ESPTransport } from \"../comms/transport\";\r\n\r\nexport enum WUStateID {\r\n    Unknown = 0,\r\n    Compiled,\r\n    Running,\r\n    Completed,\r\n    Failed,\r\n    Archived,\r\n    Aborting,\r\n    Aborted,\r\n    Blocked,\r\n    Submitted,\r\n    Scheduled,\r\n    Compiling,\r\n    Wait,\r\n    UploadingFiled,\r\n    DebugPaused,\r\n    DebugRunning,\r\n    Paused,\r\n    LAST,\r\n    NotFound = 999\r\n}\r\n\r\nexport enum WUAction {\r\n    Unknown = 0,\r\n    Compile,\r\n    Check,\r\n    Run,\r\n    ExecuteExisting,\r\n    Pause,\r\n    PauseNow,\r\n    Resume,\r\n    Debug,\r\n    __size\r\n};\r\n\r\nexport interface Query {\r\n    Text: string;\r\n}\r\n\r\nexport interface ECLHelpFile {\r\n    Name: string;\r\n    Type: string;\r\n    IPAddress: string;\r\n    Description: string;\r\n    FileSize: number;\r\n    PID: number;\r\n    minActivityId: number;\r\n    maxActivityId: number;\r\n}\r\n\r\nexport interface Helpers {\r\n    ECLHelpFile: ECLHelpFile[];\r\n}\r\n\r\nexport interface ECLSchemaItem {\r\n    ColumnName: string;\r\n    ColumnType: string;\r\n    ColumnTypeCode: number;\r\n    isConditional: boolean;\r\n}\r\n\r\nexport interface ECLSchemas {\r\n    ECLSchemaItem: ECLSchemaItem[];\r\n}\r\n\r\nexport interface ECLResult {\r\n    Name: string;\r\n    Sequence: number;\r\n    Value: string;\r\n    Link: string;\r\n    FileName: string;\r\n    IsSupplied: boolean;\r\n    ShowFileContent: boolean;\r\n    Total: number;\r\n    ECLSchemas: ECLSchemas;\r\n}\r\n\r\nexport interface Results {\r\n    ECLResult: ECLResult[];\r\n}\r\n\r\nexport interface ECLTimer {\r\n    Name: string;\r\n    Value: string;\r\n    count: number;\r\n    GraphName: string;\r\n    SubGraphId?: number;\r\n}\r\n\r\nexport interface Timers {\r\n    ECLTimer: ECLTimer[];\r\n}\r\n\r\nexport interface DebugValue {\r\n    Name: string;\r\n    Value: string;\r\n}\r\n\r\nexport interface DebugValues {\r\n    DebugValue: DebugValue[];\r\n}\r\n\r\nexport interface ApplicationValue {\r\n    Application: string;\r\n    Name: string;\r\n    Value: string;\r\n}\r\n\r\nexport interface ApplicationValues {\r\n    ApplicationValue: ApplicationValue[];\r\n}\r\n\r\nexport interface AllowedClusters {\r\n    AllowedCluster: string[];\r\n}\r\n\r\nexport interface ECLException {\r\n    Source: string;\r\n    Severity: string;\r\n    Code: number;\r\n    Message: string;\r\n    FileName: string;\r\n    LineNo: number;\r\n    Column: number;\r\n}\r\n\r\nexport interface Exceptions {\r\n    ECLException: ECLException[];\r\n}\r\n\r\nexport interface ECLWorkunit {\r\n    Wuid: string;\r\n    Owner: string;\r\n    Cluster: string;\r\n    Jobname: string;\r\n    StateID: WUStateID;\r\n    State: string;\r\n    Protected: boolean;\r\n    DateTimeScheduled: Date;\r\n    IsPausing: boolean;\r\n    ThorLCR: boolean;\r\n    TotalClusterTime: string;\r\n    ApplicationValues: ApplicationValues;\r\n    HasArchiveQuery: boolean;\r\n}\r\n\r\nexport function isECLWorkunit(_: ECLWorkunit | Workunit): _ is ECLWorkunit {\r\n    return (<ECLWorkunit>_).TotalClusterTime !== undefined;\r\n}\r\n\r\nexport interface ThorLogInfo {\r\n    ProcessName: string;\r\n    ClusterGroup: string;\r\n    LogDate: string;\r\n    NumberSlaves: number;\r\n}\r\n\r\nexport interface ThorLogList {\r\n    ThorLogInfo: ThorLogInfo[];\r\n}\r\n\r\nexport interface ResourceURLs {\r\n    URL: string[];\r\n}\r\n\r\nexport interface Variables {\r\n    ECLVariable: any[];\r\n}\r\n\r\nexport interface ECLGraph {\r\n    Name: string;\r\n    Label: string;\r\n    Type: string;\r\n    Complete: boolean;\r\n    WhenStarted: Date;\r\n    WhenFinished: Date;\r\n}\r\n\r\nexport interface Graphs {\r\n    ECLGraph: ECLGraph[];\r\n}\r\n\r\nexport interface Workunit extends ECLWorkunit {\r\n    StateEx: string;\r\n    ActionEx: string;\r\n    Description: string;\r\n    PriorityClass: number;\r\n    PriorityLevel: number;\r\n    Snapshot: string;\r\n    ResultLimit: number;\r\n    Archived: boolean;\r\n    EventSchedule: number;\r\n    HaveSubGraphTimings: boolean;\r\n    Query: Query;\r\n    Helpers: Helpers;\r\n    Results: Results;\r\n    Timers: Timers;\r\n    Exceptions: Exceptions;\r\n    DebugValues: DebugValues;\r\n    AllowedClusters: AllowedClusters;\r\n    ErrorCount: number;\r\n    WarningCount: number;\r\n    InfoCount: number;\r\n    AlertCount: number;\r\n    GraphCount: number;\r\n    SourceFileCount: number;\r\n    SourceFiles: SourceFiles;\r\n    ResultCount: number;\r\n    VariableCount: number;\r\n    Variables: Variables;\r\n    TimerCount: number;\r\n    HasDebugValue: boolean;\r\n    ApplicationValueCount: number;\r\n    XmlParams: string;\r\n    AccessFlag: number;\r\n    ClusterFlag: number;\r\n    ResultViewCount: number;\r\n    ResourceURLCount: number;\r\n    DebugValueCount: number;\r\n    WorkflowCount: number;\r\n    Graphs: Graphs;\r\n    ThorLogList: ThorLogList;\r\n    ResourceURLs: ResourceURLs;\r\n}\r\n\r\nexport function isWorkunit(_: ECLWorkunit | Workunit): _ is Workunit {\r\n    return (<Workunit>_).StateEx !== undefined;\r\n}\r\n\r\nexport interface WUInfoRequest {\r\n    Wuid: string;\r\n    TruncateEclTo64k?: boolean;\r\n    Type?: string;\r\n    IncludeExceptions?: boolean;\r\n    IncludeGraphs?: boolean;\r\n    IncludeSourceFiles?: boolean;\r\n    IncludeResults?: boolean;\r\n    IncludeResultsViewNames?: boolean;\r\n    IncludeVariables?: boolean;\r\n    IncludeTimers?: boolean;\r\n    IncludeDebugValues?: boolean;\r\n    IncludeApplicationValues?: boolean;\r\n    IncludeWorkflows?: boolean;\r\n    IncludeXmlSchemas?: boolean;\r\n    IncludeResourceURLs?: boolean;\r\n    SuppressResultSchemas?: boolean;\r\n    ThorSlaveIP?: string;\r\n}\r\n\r\nexport interface ECLSourceFile {\r\n    FileCluster: string;\r\n    Name: string;\r\n    Count: number;\r\n}\r\n\r\nexport interface SourceFiles {\r\n    ECLSourceFile: ECLSourceFile[];\r\n}\r\n\r\nexport interface WUInfoResponse {\r\n    Workunit: Workunit;\r\n    AutoRefresh: number;\r\n    CanCompile: boolean;\r\n    ThorSlaveIP?: any;\r\n    ResultViews: any[];\r\n    SecMethod?: any;\r\n}\r\n\r\nexport interface ApplicationValue {\r\n    Application: string;\r\n    Name: string;\r\n    Value: string;\r\n}\r\n\r\nexport interface ApplicationValues {\r\n    ApplicationValue: ApplicationValue[];\r\n}\r\n\r\nexport interface Workunits {\r\n    ECLWorkunit: ECLWorkunit[];\r\n}\r\n\r\nexport interface WUQueryRequest {\r\n    Wuid?: string;\r\n    Owner?: string;\r\n    Jonname?: string;\r\n}\r\n\r\nexport interface WUQueryResponse {\r\n    Type: string;\r\n    LogicalFileSearchType: string;\r\n    Count: number;\r\n    PageSize: number;\r\n    NextPage: number;\r\n    LastPage: number;\r\n    NumWUs: number;\r\n    First: boolean;\r\n    PageStartFrom: number;\r\n    PageEndAt: number;\r\n    Descending: boolean;\r\n    BasicQuery: string;\r\n    Filters: string;\r\n    CacheHint: number;\r\n    Workunits: Workunits;\r\n}\r\n\r\nexport interface WUCreateResponse {\r\n    Workunit: Workunit;\r\n}\r\n\r\nexport interface WUListQueriesRequest {\r\n    QueryID: string;\r\n    QueryName: string;\r\n}\r\n\r\nexport interface WUListQueriesResponse {\r\n}\r\n\r\nexport interface WUUpdateRequest {\r\n    Wuid: string;\r\n    State?: string;\r\n    StateOrig?: string;\r\n    Jobname?: string;\r\n    JobnameOrig?: string;\r\n    QueryText?: string;\r\n    Action?: WUAction;\r\n    Description?: string;\r\n    DescriptionOrig?: string;\r\n    AddDrilldownFields?: boolean;\r\n    ResultLimit?: number;\r\n    Protected?: boolean;\r\n    ProtectedOrig?: boolean;\r\n    PriorityClass?: string;\r\n    PriorityLevel?: string;\r\n    Scope?: string;\r\n    ScopeOrig?: string;\r\n    ClusterSelection?: string;\r\n    ClusterOrig?: string;\r\n    XmlParams?: string;\r\n    ThorSlaveIP?: string;\r\n    QueryMainDefinition?: string;\r\n    DebugValues?: any[];\r\n    ApplicationValues?: any[];\r\n}\r\n\r\nexport interface WUPushEventRequest {\r\n    EventName: string;\r\n    EventText: string;\r\n}\r\n\r\nexport interface WUPushEventResponse {\r\n}\r\n\r\nexport interface WUUpdateResponse {\r\n    Workunit: Workunit;\r\n}\r\n\r\nexport interface WUSubmitRequest {\r\n    Wuid: string;\r\n    Cluster: string;\r\n    Queue?: string;\r\n    Snapshot?: string;\r\n    MaxRunTime?: number;\r\n    BlockTillFinishTimer?: boolean;\r\n    SyntaxCheck?: boolean;\r\n    NotifyCluster?: boolean;\r\n}\r\n\r\nexport interface WUSubmitResponse {\r\n}\r\n\r\nexport interface WUResubmitRequest {\r\n    Wuids: string[];\r\n    ResetWorkflow: boolean;\r\n    CloneWorkunit: boolean;\r\n    BlockTillFinishTimer?: number;\r\n}\r\n\r\nexport interface WU {\r\n    WUID: string;\r\n}\r\n\r\nexport interface WUs {\r\n    WU: WU[];\r\n}\r\n\r\nexport interface WUResubmitResponse {\r\n    WUs: WUs;\r\n}\r\nexport interface WUQueryDetailsRequest {\r\n    QueryId: string;\r\n    QuerySet: string;\r\n    IncludeStateOnClusters: boolean;\r\n    IncludeSuperFiles: boolean;\r\n    IncludeWsEclAddresses: boolean;\r\n    CheckAllNodes: boolean;\r\n}\r\n\r\nexport interface WUQueryDetailsResponse {\r\n    QueryId: string;\r\n    QuerySet: string;\r\n    QueryName: string;\r\n    Wuid: string;\r\n    Dll: string;\r\n    Suspended: boolean;\r\n    Activated: boolean;\r\n    SuspendedBy?: any;\r\n    PublishedBy?: any;\r\n    Comment: string;\r\n    LogicalFiles: any[];\r\n    IsLibrary: boolean;\r\n    Priority?: any;\r\n    WUSnapShot: string;\r\n    CompileTime: Date;\r\n    LibrariesUsed: any[];\r\n    CountGraphs: number;\r\n    GraphIds: any[];\r\n    ResourceURLCount: number;\r\n    WsEclAddresses: any[];\r\n}\r\n\r\nexport type WUActionType = \"SetToFailed\" | \"Pause\" | \"PauseNow\" | \"Resume\" | \"Abort\" | \"Delete\" | \"Restore\" | \"Deschedule\" | \"Reschedule\";\r\nexport interface WUActionRequest {\r\n    Wuids: string[];\r\n    WUActionType: WUActionType;\r\n    Cluster?: string;\r\n    Owner?: string;\r\n    State?: string;\r\n    StartDate?: string;\r\n    EndDate?: string;\r\n    ECL?: string;\r\n    Jobname?: string;\r\n    Test?: string;\r\n    CurrentPage?: number;\r\n    PageSize?: number;\r\n    Sortby?: number;\r\n    Descending?: boolean;\r\n    EventServer?: string;\r\n    EventName?: string;\r\n    PageFrom?: number;\r\n    BlockTillFinishTimer?: number;\r\n}\r\n\r\nexport interface WUActionResult {\r\n    Wuid: string;\r\n    Action: string;\r\n    Result: string;\r\n}\r\n\r\nexport interface ActionResults {\r\n    WUActionResult: WUActionResult[];\r\n}\r\n\r\nexport interface WUActionResponse {\r\n    ActionResults: ActionResults;\r\n}\r\n\r\nexport interface WUGetZAPInfoRequest {\r\n    WUID: string;\r\n}\r\n\r\nexport interface WUGetZAPInfoResponse {\r\n    WUID: string;\r\n    ESPIPAddress: string;\r\n    ThorIPAddress?: any;\r\n    BuildVersion: string;\r\n    Archive?: any;\r\n}\r\n\r\nexport interface WUShowScheduledRequest {\r\n    Cluster: string;\r\n    EventName: string;\r\n    PushEventName: string;\r\n    PushEventText: string;\r\n    State: string;\r\n}\r\n\r\nexport interface WUShowScheduledResponse {\r\n}\r\n\r\nexport interface WUQuerySetQueryActionRequest {\r\n    Action: string;\r\n    QuerySetName: string;\r\n    Queries: any[];\r\n}\r\n\r\nexport interface Result {\r\n    QueryId: string;\r\n    Suspended: boolean;\r\n    Success: boolean;\r\n    Code?: any;\r\n    Message?: any;\r\n}\r\n\r\nexport interface Results2 {\r\n    Result: Result[];\r\n}\r\n\r\nexport interface WUQuerySetQueryActionResponse {\r\n    Action: string;\r\n    QuerySetName: string;\r\n    Results: Results2;\r\n}\r\n\r\nexport interface WUQuerySetAliasActionRequest {\r\n    Action: string;\r\n    QuerySetName: string;\r\n    Queries: any[];\r\n}\r\n\r\nexport interface AliasResult {\r\n    Name?: any;\r\n    Success: boolean;\r\n    Code?: any;\r\n    Message?: any;\r\n}\r\n\r\nexport interface AliasResults {\r\n    Result: AliasResult[];\r\n}\r\n\r\nexport interface WUQuerySetAliasActionResponse {\r\n    Action: string;\r\n    QuerySetName: string;\r\n    Results: AliasResults;\r\n}\r\n\r\nexport interface WUPublishWorkunitRequest {\r\n    Wuid: string;\r\n    Cluster: string;\r\n    JobName: string;\r\n    Activate: string;\r\n    NotifyCluster: boolean;\r\n    Wait: number;\r\n    NoReload: boolean;\r\n    UpdateWorkUnitName: boolean;\r\n    memoryLimit: string;\r\n    TimeLimit: string;\r\n    WarnTimeLimit: string;\r\n    Priority: string;\r\n    RemoteDali: string;\r\n    Comment: string;\r\n    DontCopyFiles: boolean;\r\n    SourceProcess: string;\r\n    AllowForeignFiles: boolean;\r\n    UpdateDfs: boolean;\r\n    UpdateSuperFiles: boolean;\r\n    UpdateCloneFrom: boolean;\r\n    AppendCluster: boolean;\r\n}\r\n\r\nexport interface WUPublishWorkunitResponse {\r\n    Wuid: string;\r\n    Result?: any;\r\n    QuerySet: string;\r\n    QueryName: string;\r\n    QueryId: string;\r\n    ReloadFailed: boolean;\r\n    Suspended?: any;\r\n    ErrorMessage?: any;\r\n}\r\n\r\nexport interface WUGetGraphRequest {\r\n    Wuid: string;\r\n    GraphName: string;\r\n    SubGraphId: string;\r\n}\r\n\r\nexport interface ECLGraphEx {\r\n    Name: string;\r\n    Label: string;\r\n    Type: string;\r\n    Graph: string;\r\n    Complete: boolean;\r\n}\r\n\r\nexport interface GraphsEx {\r\n    ECLGraphEx: ECLGraphEx[];\r\n}\r\n\r\nexport interface WUGetGraphResponse {\r\n    Graphs: GraphsEx;\r\n}\r\n\r\nexport interface WUResultRequest {\r\n    Wuid?: string;\r\n    Sequence?: number;\r\n    ResultName?: string;\r\n    LogicalName?: string;\r\n    Cluster?: string;\r\n    SuppressXmlSchema?: boolean;\r\n    BypassCachedResult?: boolean;\r\n    FilterBy?: any[];\r\n    Start: number;\r\n    Count: number;\r\n}\r\n\r\nexport interface XmlSchema {\r\n    \"@name\": string;\r\n    xml: string;\r\n}\r\n\r\nexport interface Result {\r\n    XmlSchema: XmlSchema;\r\n    \"@xmlSchema\": string;\r\n    Row: any[];\r\n}\r\n\r\nexport interface WUResultResponse {\r\n    Wuid: string;\r\n    Sequence: number;\r\n    LogicalName?: any;\r\n    Cluster?: any;\r\n    Name: string;\r\n    Start: number;\r\n    Requested: number;\r\n    Count: number;\r\n    Total: number;\r\n    Result: Result;\r\n}\r\n\r\nexport interface WUQueryGetGraphRequest {\r\n    Target: string;\r\n    QueryId: string;\r\n    GraphName: string;\r\n    SubGraphId: string;\r\n}\r\n\r\nexport interface WUQueryGetGraphResponse {\r\n}\r\n\r\nexport interface WUFileRequest {\r\n    Name: string;\r\n    Wuid: string;\r\n    Type: string;\r\n    Option: string;\r\n    SlaveIP: string;\r\n    IPAddress: string;\r\n    Description: string;\r\n    QuerySet: string;\r\n    Query: string;\r\n    Process: string;\r\n    ClusterGroup: string;\r\n    LogDate: string;\r\n    SlaveNumber: number;\r\n    SizeLimit: number;\r\n    PlainText: string;\r\n}\r\n\r\nexport interface WUGetStatsRequest {\r\n    WUID: string;\r\n    CreatorType: string;\r\n    Creator: string;\r\n    ScopeType: string;\r\n    Scope: string;\r\n    Kind: string;\r\n    Measure: string;\r\n    MinScopeDepth: number;\r\n    MaxScopeDepth: number;\r\n    IncludeGraphs: boolean;\r\n    CreateDescriptions: boolean;\r\n    MinValue: number;\r\n    MaxValue: number;\r\n    Filter: string;\r\n}\r\n\r\nexport interface WUStatisticItem {\r\n    Creator: string;\r\n    CreatorType: string;\r\n    Scope: string;\r\n    ScopeType: string;\r\n    TimeStamp: Date;\r\n    Measure: string;\r\n    Kind: string;\r\n    Value: any;\r\n    RawValue: any;\r\n    Wuid: string;\r\n    Max?: number;\r\n    Count?: number;\r\n    Description: string;\r\n}\r\n\r\nexport interface Statistics {\r\n    WUStatisticItem: WUStatisticItem[];\r\n}\r\n\r\nexport interface WUGetStatsResponse {\r\n    WUID: string;\r\n    Statistics: Statistics;\r\n}\r\n\r\nexport interface WUCDebugRequest {\r\n    Wuid: string;\r\n    Command: string;\r\n}\r\n\r\nexport interface WUCDebugResponse {\r\n    Result: string;\r\n}\r\n\r\nexport namespace WUDetails {\r\n    export interface AttributeFilter {\r\n        Name: string;\r\n        ExactValue: string;\r\n        MinValue: string;\r\n        MaxValue: string;\r\n    }\r\n\r\n    export interface Filter {\r\n        MaxDepth: number;\r\n        Scopes: string[];\r\n        Ids: string[];\r\n        ScopeTypes: string[];\r\n        AttributeFilters: AttributeFilter[];\r\n    }\r\n\r\n    export interface Nested {\r\n        Depth: number;\r\n        ScopeTypes: string[];\r\n    }\r\n\r\n    export interface ScopeOverride {\r\n        scopeType: string;\r\n        Attributes: string[];\r\n    }\r\n\r\n    export interface AttributeToReturn {\r\n        OnlyDynamic: boolean;\r\n        MinVersion: string;\r\n        Measure: string;\r\n        Attributes: string[];\r\n        ScopeOverrides: ScopeOverride[];\r\n    }\r\n\r\n    export interface ScopeOptions {\r\n        IncludeMatchedScopesInResults: boolean;\r\n        IncludeScope: boolean;\r\n        IncludeId: boolean;\r\n        IncludeScopeType: boolean;\r\n    }\r\n\r\n    export interface AttributeOptions {\r\n        IncludeName: boolean;\r\n        IncludeRawValue: boolean;\r\n        IncludeFormatted: boolean;\r\n        IncludeMeasure: boolean;\r\n        IncludeCreator: boolean;\r\n        IncludeCreatorType: boolean;\r\n    }\r\n\r\n    export interface Request {\r\n        WUID: string;\r\n        Filter?: Filter;\r\n        Nested?: Nested;\r\n        AttributeToReturn?: AttributeToReturn;\r\n        ScopeOptions?: ScopeOptions;\r\n        AttributeOptions?: AttributeOptions;\r\n    }\r\n\r\n    export interface Attribute {\r\n        Name: string;\r\n        RawValue?: any;\r\n        Formatted: any;\r\n        Measure?: any;\r\n        Creator?: any;\r\n        CreatorType?: any;\r\n    }\r\n\r\n    export interface Attributes {\r\n        Attribute: Attribute[];\r\n    }\r\n\r\n    export interface Scope {\r\n        Scope: string;\r\n        Id?: any;\r\n        ScopeType?: any;\r\n        Attributes: Attributes;\r\n    }\r\n\r\n    export interface Scopes {\r\n        Scope: Scope[];\r\n    }\r\n\r\n    export interface Response {\r\n        maxVersion: number;\r\n        WUID: string;\r\n        Scopes: Scopes;\r\n    }\r\n}\r\n\r\nexport class Service {\r\n    private _transport: ESPTransport;\r\n\r\n    constructor(transport: ITransport | string) {\r\n        if (typeof transport === \"string\") {\r\n            transport = createTransport(transport);\r\n        }\r\n        this._transport = new ESPTransport(transport, \"WsWorkunits\", \"1.67\");\r\n    }\r\n\r\n    WUQuery(request: WUQueryRequest = {}): Promise<WUQueryResponse> {\r\n        return this._transport.send(\"WUQuery\", request);\r\n    }\r\n\r\n    WUInfo(_request: WUInfoRequest): Promise<WUInfoResponse> {\r\n        const request: WUInfoRequest = {\r\n            Wuid: \"\",\r\n            TruncateEclTo64k: true,\r\n            IncludeExceptions: false,\r\n            IncludeGraphs: false,\r\n            IncludeSourceFiles: false,\r\n            IncludeResults: false,\r\n            IncludeResultsViewNames: false,\r\n            IncludeVariables: false,\r\n            IncludeTimers: false,\r\n            IncludeDebugValues: false,\r\n            IncludeApplicationValues: false,\r\n            IncludeWorkflows: false,\r\n            IncludeXmlSchemas: false,\r\n            IncludeResourceURLs: false,\r\n            SuppressResultSchemas: true,\r\n            ..._request\r\n        };\r\n        return this._transport.send(\"WUInfo\", request);\r\n    }\r\n\r\n    WUCreate(): Promise<WUCreateResponse> {\r\n        return this._transport.send(\"WUCreate\");\r\n    }\r\n\r\n    private objToESPArray(id: string, obj: Object, request: any) {\r\n        let count = 0;\r\n        for (const key in obj) {\r\n            if (obj.hasOwnProperty(key)) {\r\n                request[`${id}s.${id}.${count}.Name`] = key;\r\n                request[`${id}s.${id}.${count}.Value`] = obj[key];\r\n                ++count;\r\n            }\r\n        }\r\n        request[`${id}s.${id}.itemcount`] = count;\r\n    }\r\n\r\n    WUUpdate(request: WUUpdateRequest, appValues: { [key: string]: string | number | boolean } = {}, debugValues: { [key: string]: string | number | boolean } = {}): Promise<WUUpdateResponse> {\r\n        this.objToESPArray(\"ApplicationValue\", appValues, request);\r\n        this.objToESPArray(\"DebugValue\", debugValues, request);\r\n        return this._transport.send(\"WUUpdate\", request);\r\n    }\r\n\r\n    WUSubmit(request: WUSubmitRequest): Promise<WUSubmitResponse> {\r\n        return this._transport.send(\"WUSubmit\", request);\r\n    }\r\n\r\n    WUResubmit(request: WUResubmitRequest): Promise<WUResubmitResponse> {\r\n        this._transport.toESPStringArray(request, \"Wuids\");\r\n        return this._transport.send(\"WUResubmit\", request);\r\n    }\r\n\r\n    WUQueryDetails(request: WUQueryDetailsRequest): Promise<WUQueryDetailsResponse> {\r\n        return this._transport.send(\"WUQueryDetails\", request);\r\n    }\r\n\r\n    WUListQueries(request: WUListQueriesRequest): Promise<WUListQueriesResponse> {\r\n        return this._transport.send(\"WUListQueries\", request);\r\n    }\r\n\r\n    WUPushEvent(request: WUPushEventRequest): Promise<WUPushEventResponse> {\r\n        return this._transport.send(\"WUPushEvent\", request);\r\n    }\r\n\r\n    WUAction(request: WUActionRequest): Promise<WUActionResponse> {\r\n        this._transport.toESPStringArray(request, \"Wuids\");\r\n        (<any>request).ActionType = request.WUActionType; //  v5.x compatibility\r\n        return this._transport.send(\"WUAction\", request);\r\n    }\r\n\r\n    WUGetZAPInfo(request: WUGetZAPInfoRequest): Promise<WUGetZAPInfoResponse> {\r\n        return this._transport.send(\"WUGetZAPInfo\", request);\r\n    }\r\n\r\n    WUShowScheduled(request: WUShowScheduledRequest): Promise<WUShowScheduledResponse> {\r\n        return this._transport.send(\"WUShowScheduled\", request);\r\n    }\r\n\r\n    WUQuerySetAliasAction(request: WUQuerySetAliasActionRequest): Promise<WUQuerySetAliasActionResponse> {\r\n        return this._transport.send(\"WUQuerySetAliasAction\", request);\r\n    }\r\n\r\n    WUQuerySetQueryAction(request: WUQuerySetQueryActionRequest): Promise<WUQuerySetQueryActionResponse> {\r\n        return this._transport.send(\"WUQuerySetQueryAction\", request);\r\n    }\r\n\r\n    WUPublishWorkunit(request: WUPublishWorkunitRequest): Promise<WUPublishWorkunitResponse> {\r\n        return this._transport.send(\"WUPublishWorkunit\", request);\r\n    }\r\n\r\n    WUGetGraph(request: WUGetGraphRequest): Promise<WUGetGraphResponse> {\r\n        return this._transport.send(\"WUGetGraph\", request);\r\n    }\r\n\r\n    WUResult(request: WUResultRequest): Promise<WUResultResponse> {\r\n        return this._transport.send(\"WUResult\", request);\r\n    }\r\n\r\n    WUQueryGetGraph(request: WUQueryGetGraphRequest): Promise<WUQueryGetGraphResponse> {\r\n        return this._transport.send(\"WUQueryGetGraph\", request);\r\n    }\r\n\r\n    WUFile(request: WUFileRequest): Promise<string> {\r\n        return this._transport.send(\"WUFile\", request, \"text\");\r\n    }\r\n\r\n    WUGetStats(request: WUGetStatsRequest): Promise<WUGetStatsResponse> {\r\n        return this._transport.send(\"WUGetStats\", request);\r\n    }\r\n\r\n    WUDetails(request: WUDetails.Request): Promise<WUDetails.Response> {\r\n        return this._transport.send(\"WUDetails\", request);\r\n    }\r\n\r\n    WUCDebug(request: WUCDebugRequest): Promise<XMLNode> {\r\n        return this._transport.send(\"WUCDebug\", request).then((response) => {\r\n            const retVal = xml2json(response.Result);\r\n            if (retVal.children.length) {\r\n                return retVal.children[0];\r\n            }\r\n            return null;\r\n        });\r\n    }\r\n}\r\n","import { createTransport, ITransport } from \"../../comms/index\";\r\nimport { ESPTransport } from \"../comms/transport\";\r\n\r\nexport interface EclServerQueueRequest {\r\n    EclServerQueue?: string;\r\n}\r\n\r\nexport interface TpLogicalCluster {\r\n    Name: string;\r\n    Queue?: any;\r\n    LanguageVersion: string;\r\n    Process?: any;\r\n    Type: string;\r\n}\r\n\r\nexport interface TpLogicalClusters {\r\n    TpLogicalCluster: TpLogicalCluster[];\r\n}\r\n\r\nexport interface TpLogicalClusterQueryResponse {\r\n    default?: TpLogicalCluster;\r\n    TpLogicalClusters: TpLogicalClusters;\r\n}\r\n\r\nexport class Service {\r\n    private _transport: ESPTransport;\r\n\r\n    constructor(transport: ITransport | string) {\r\n        if (typeof transport === \"string\") {\r\n            transport = createTransport(transport);\r\n        }\r\n        this._transport = new ESPTransport(transport, \"WsTopology\", \"1.25\");\r\n    }\r\n\r\n    TpLogicalClusterQuery(request: EclServerQueueRequest = {}): Promise<TpLogicalClusterQueryResponse> {\r\n        return this._transport.send(\"WUUpdate\", request);\r\n    }\r\n\r\n    DefaultTpLogicalClusterQuery(request: EclServerQueueRequest = {}): Promise<TpLogicalCluster> {\r\n        return this.TpLogicalClusterQuery(request).then((response) => {\r\n            if (response.default) {\r\n                return response.default;\r\n            }\r\n            let firstHThor;\r\n            let first;\r\n            response.TpLogicalClusters.TpLogicalCluster.some((item, idx) => {\r\n                if (idx === 0) {\r\n                    first = item;\r\n                }\r\n                if (item.Type === \"hthor\") {\r\n                    firstHThor = item;\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            return firstHThor || first;\r\n        });\r\n    }\r\n}\r\n","import { createTransport, ITransport } from \"../../comms/index\";\r\nimport { ESPTransport } from \"../comms/transport\";\r\n\r\nexport interface ActivityRequest {\r\n    ChatURL?: string;\r\n    BannerContent?: string;\r\n    BannerColor?: string;\r\n    BannerSize?: string;\r\n    BannerScroll?: string;\r\n    BannerAction?: string;\r\n    EnableChatURL?: boolean;\r\n    FromSubmitBtn?: boolean;\r\n    SortBy?: string;\r\n    Descending?: boolean;\r\n}\r\n\r\nexport interface TargetCluster {\r\n    ClusterName: string;\r\n    QueueName: string;\r\n    QueueStatus: string;\r\n    StatusDetails: string;\r\n    Warning?: any;\r\n    ClusterType: number;\r\n    ClusterSize: number;\r\n    ClusterStatus: number;\r\n}\r\n\r\nexport interface ThorClusterList {\r\n    TargetCluster: TargetCluster[];\r\n}\r\n\r\nexport interface TargetCluster2 {\r\n    ClusterName: string;\r\n    QueueName: string;\r\n    QueueStatus: string;\r\n    StatusDetails: string;\r\n    Warning?: any;\r\n    ClusterType: number;\r\n    ClusterSize: number;\r\n    ClusterStatus: number;\r\n}\r\n\r\nexport interface RoxieClusterList {\r\n    TargetCluster: TargetCluster2[];\r\n}\r\n\r\nexport interface TargetCluster3 {\r\n    ClusterName: string;\r\n    QueueName: string;\r\n    QueueStatus: string;\r\n    StatusDetails: string;\r\n    Warning?: any;\r\n    ClusterType: number;\r\n    ClusterSize: number;\r\n    ClusterStatus: number;\r\n}\r\n\r\nexport interface HThorClusterList {\r\n    TargetCluster: TargetCluster3[];\r\n}\r\n\r\nexport interface ActiveWorkunit {\r\n    Wuid: string;\r\n    State: string;\r\n    StateID: number;\r\n    Owner: string;\r\n    Jobname: string;\r\n    Server: string;\r\n    Instance: string;\r\n    Priority: string;\r\n    Extra?: any;\r\n    GraphName?: any;\r\n    Duration?: any;\r\n    GID?: any;\r\n    QueueName: string;\r\n    MemoryBlocked?: any;\r\n    IsPausing: boolean;\r\n    Warning?: any;\r\n    ClusterName: string;\r\n    ClusterType: string;\r\n    ClusterQueueName: string;\r\n    TargetClusterName: string;\r\n}\r\n\r\nexport interface Running {\r\n    ActiveWorkunit: ActiveWorkunit[];\r\n}\r\n\r\nexport interface ServerJobQueue {\r\n    QueueName: string;\r\n    ServerName: string;\r\n    ServerType: string;\r\n    QueueStatus: string;\r\n    StatusDetails: string;\r\n    NetworkAddress: string;\r\n    Port?: number;\r\n}\r\n\r\nexport interface ServerJobQueues {\r\n    ServerJobQueue: ServerJobQueue[];\r\n}\r\n\r\nexport interface ActivityResponse {\r\n    Build: string;\r\n    ThorClusterList: ThorClusterList;\r\n    RoxieClusterList: RoxieClusterList;\r\n    HThorClusterList: HThorClusterList;\r\n    Running: Running;\r\n    BannerContent: string;\r\n    BannerColor: string;\r\n    BannerSize: string;\r\n    BannerScroll: string;\r\n    ChatURL: string;\r\n    ShowBanner: number;\r\n    ShowChatURL: number;\r\n    SortBy?: any;\r\n    Descending: boolean;\r\n    SuperUser: boolean;\r\n    AccessRight: string;\r\n    ServerJobQueues: ServerJobQueues;\r\n}\r\n\r\nexport interface RootObject {\r\n    ActivityResponse: ActivityResponse;\r\n}\r\n\r\nexport class Service {\r\n    private _transport: ESPTransport;\r\n\r\n    constructor(transport: ITransport | string) {\r\n        if (typeof transport === \"string\") {\r\n            transport = createTransport(transport);\r\n        }\r\n        this._transport = new ESPTransport(transport, \"WsSMC\", \"1.19\");\r\n    }\r\n\r\n    Activity(request: ActivityRequest): Promise<ActivityResponse> {\r\n        return this._transport.send(\"Activity\", request);\r\n    }\r\n}\r\n","import { createTransport, ITransport } from \"../../comms/index\";\r\nimport { ESPTransport } from \"../comms/transport\";\r\n\r\nexport interface DFULogicalFile {\r\n    Prefix: string;\r\n    NodeGroup: string;\r\n    Directory: string;\r\n    Description?: any;\r\n    Parts: string;\r\n    Name: string;\r\n    Owner: string;\r\n    Totalsize: string;\r\n    RecordCount: string;\r\n    Modified: string;\r\n    LongSize?: any;\r\n    LongRecordCount?: any;\r\n    isSuperfile: boolean;\r\n    isDirectory: boolean;\r\n    Replicate: boolean;\r\n    IntSize: number;\r\n    IntRecordCount: number;\r\n    FromRoxieCluster?: any;\r\n    BrowseData: boolean;\r\n    IsCompressed: boolean;\r\n    ContentType: string;\r\n    CompressedFileSize?: any;\r\n    SuperOwners?: any;\r\n    Persistent: boolean;\r\n    IsProtected: boolean;\r\n}\r\n\r\nexport interface DFULogicalFiles {\r\n    DFULogicalFile: DFULogicalFile[];\r\n}\r\n\r\nexport interface DFUQueryResponse {\r\n    DFULogicalFiles: DFULogicalFiles;\r\n    Prefix?: any;\r\n    NodeGroup?: any;\r\n    LogicalName?: any;\r\n    Description?: any;\r\n    Owner?: any;\r\n    StartDate?: any;\r\n    EndDate?: any;\r\n    FileType?: any;\r\n    FileSizeFrom: number;\r\n    FileSizeTo: number;\r\n    FirstN: number;\r\n    PageSize: number;\r\n    PageStartFrom: number;\r\n    LastPageFrom: number;\r\n    PageEndAt: number;\r\n    PrevPageFrom: number;\r\n    NextPageFrom: number;\r\n    NumFiles: number;\r\n    Sortby?: any;\r\n    Descending: boolean;\r\n    BasicQuery: string;\r\n    ParametersForPaging: string;\r\n    Filters: string;\r\n    CacheHint: number;\r\n    IsSubsetOfFiles?: any;\r\n    Warning?: any;\r\n}\r\n\r\nexport interface RootObject {\r\n    DFUQueryResponse: DFUQueryResponse;\r\n}\r\n\r\nexport class Service {\r\n    private _transport: ESPTransport;\r\n\r\n    constructor(transport: ITransport | string) {\r\n        if (typeof transport === \"string\") {\r\n            transport = createTransport(transport);\r\n        }\r\n        this._transport = new ESPTransport(transport, \"WsDFU\", \"1.35\");\r\n    }\r\n}\r\n","/**\r\n * IObserverHandle - Reference to an observing instance\r\n */\r\nexport interface IObserverHandle {\r\n    release();\r\n    unwatch();\r\n}\r\n\r\nclass ObserverHandle<T extends string> implements IObserverHandle {\r\n    private eventTarget: Observable<T>;\r\n    private eventID: T;\r\n    private callback: Function;\r\n\r\n    constructor(eventTarget: Observable<T>, eventID: T, callback: Function) {\r\n        this.eventTarget = eventTarget;\r\n        this.eventID = eventID;\r\n        this.callback = callback;\r\n    }\r\n\r\n    release() {\r\n        this.eventTarget.removeObserver(this.eventID, this.callback);\r\n    }\r\n\r\n    unwatch() {\r\n        this.release();\r\n    }\r\n}\r\n\r\nexport type EventID = string;\r\nexport class Observable<T extends EventID> {\r\n    private _knownEvents: EventID[];\r\n    private _eventObservers: { [eventID: string]: Function[] } = {};\r\n\r\n    constructor(...events: T[]) {\r\n        this._knownEvents = events;\r\n    }\r\n\r\n    addObserver(eventID: T, callback: Function): IObserverHandle {\r\n        let eventObservers = this._eventObservers[eventID];\r\n        if (!eventObservers) {\r\n            eventObservers = [];\r\n            this._eventObservers[eventID] = eventObservers;\r\n        }\r\n        eventObservers.push(callback);\r\n        return new ObserverHandle<T>(this, eventID, callback);\r\n    }\r\n\r\n    removeObserver(eventID: T, callback: Function): this {\r\n        const eventObservers = this._eventObservers[eventID];\r\n        if (eventObservers) {\r\n            for (let i = eventObservers.length - 1; i >= 0; --i) {\r\n                if (eventObservers[i] === callback) {\r\n                    eventObservers.splice(i, 1);\r\n                }\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    dispatchEvent(eventID: T, ...args: any[]): this {\r\n        const eventObservers = this._eventObservers[eventID];\r\n        if (eventObservers) {\r\n            for (const observer of eventObservers) {\r\n                observer(...args);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    private _hasObserver(eventID: string): boolean {\r\n        const eventObservers = this._eventObservers[eventID];\r\n        for (const observer in eventObservers) {\r\n            if (eventObservers[observer]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    hasObserver(_eventID?: T): boolean {\r\n        if (_eventID !== void 0) {\r\n            return this._hasObserver(_eventID);\r\n        }\r\n        for (const eventID in this._eventObservers) {\r\n            if (this._hasObserver(eventID)) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n","import { hashSum } from \"../util/hashSum\";\r\nimport { exists, inner } from \"../util/object\";\r\nimport { Observable } from \"../util/observer\";\r\n\r\nexport interface IEvent {\r\n    id: string;\r\n    oldValue: any;\r\n    newValue: any;\r\n}\r\n\r\nexport type StatePropCallback = (changes: IEvent) => void;\r\nexport type StateCallback = (changes: IEvent[]) => void;\r\nexport type StateEvents = \"propChanged\" | \"changed\";\r\nexport class StateObject<U, I> {\r\n    private _espState: U = <U>{};\r\n    private _espStateCache: { [key: string]: string } = {};\r\n    private _events = new Observable<StateEvents>();\r\n\r\n    protected clear(newVals?: Partial<I>) {\r\n        this._espState = <U>{};\r\n        this._espStateCache = {};\r\n        if (newVals !== void 0) {\r\n            this.set(<I>newVals);\r\n        }\r\n    }\r\n\r\n    protected get(): U;\r\n    protected get<K extends keyof U>(key: K, defValue?: U[K]): U[K];\r\n    protected get<K extends keyof U>(key?: K, defValue?: U[K]): U | U[K] {\r\n        if (key === void 0) {\r\n            return this._espState;\r\n        }\r\n        return this.has(key) ? this._espState[key] : defValue;\r\n    }\r\n    protected innerXXX(qualifiedID: string, defValue?: any) {\r\n        return exists(qualifiedID, this._espState) ? inner(qualifiedID, this._espState) : defValue;\r\n    }\r\n\r\n    protected set(newVals: I): IEvent[];\r\n    protected set<K extends keyof U>(key: K, newVal: U[K], batchMode?: boolean): IEvent;\r\n    protected set<K extends keyof U>(keyOrNewVals: K | U, newVal?: U[K], batchMode: boolean = false): IEvent[] | IEvent {\r\n        if (typeof keyOrNewVals === \"string\") {\r\n            return this.setSingle(keyOrNewVals, newVal, batchMode);\r\n        }\r\n        return this.setAll(<Partial<U>>keyOrNewVals);\r\n    }\r\n\r\n    private setSingle<K extends keyof U>(key: K, newVal: U[K], batchMode: boolean): IEvent {\r\n        const oldCacheVal = this._espStateCache[(<string>key)];\r\n        const newCacheVal = hashSum(newVal);\r\n        if (oldCacheVal !== newCacheVal) {\r\n            this._espStateCache[key] = newCacheVal;\r\n            const oldVal = this._espState[key];\r\n            this._espState[key] = newVal;\r\n            const changedInfo: IEvent = { id: key, oldValue: oldVal, newValue: newVal };\r\n            if (!batchMode) {\r\n                this._events.dispatchEvent(\"propChanged\", changedInfo);\r\n                this._events.dispatchEvent(\"changed\", [changedInfo]);\r\n            }\r\n            return changedInfo;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private setAll(_: Partial<U>): IEvent[] {\r\n        const changed: IEvent[] = [];\r\n        for (const key in _) {\r\n            if (_.hasOwnProperty(key)) {\r\n                const changedInfo: IEvent = this.setSingle(key, _[key], true);\r\n                if (changedInfo) {\r\n                    changed.push(changedInfo);\r\n                }\r\n            }\r\n        }\r\n        if (changed.length) {\r\n            for (const changeInfo of changed) {\r\n                this._events.dispatchEvent((\"propChanged\"), changeInfo);\r\n            }\r\n            this._events.dispatchEvent((\"changed\"), changed);\r\n        }\r\n        return changed;\r\n    }\r\n\r\n    protected has<K extends keyof U>(key: K): boolean {\r\n        return this._espState[key] !== void 0;\r\n    }\r\n\r\n    on(eventID: StateEvents, callback: StateCallback);\r\n    on(eventID: StateEvents, propID: keyof U, callback: StatePropCallback);\r\n    on(eventID: StateEvents, propIDOrCallback: StateCallback | keyof U, callback?: StatePropCallback) {\r\n        if (this.isCallback(propIDOrCallback)) {\r\n            switch (eventID) {\r\n                case \"changed\":\r\n                    return this._events.addObserver(eventID, propIDOrCallback);\r\n                default:\r\n            }\r\n        } else {\r\n            switch (eventID) {\r\n                case \"propChanged\":\r\n                    return this._events.addObserver(eventID, (changeInfo: IEvent) => {\r\n                        if (changeInfo.id === propIDOrCallback) {\r\n                            callback(changeInfo);\r\n                        }\r\n                    });\r\n                default:\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    protected isCallback(propIDOrCallback: StateCallback | keyof U): propIDOrCallback is StateCallback {\r\n        return (typeof propIDOrCallback === \"function\");\r\n    }\r\n\r\n    protected hasEventListener(): boolean {\r\n        return this._events.hasObserver();\r\n    }\r\n}\r\n\r\nexport class Cache<I, C> {\r\n    private _cache: { [id: string]: C } = {};\r\n    private _calcID: (espObj: I | C) => string;\r\n\r\n    static hash(...args) {\r\n        return hashSum({ ...args });\r\n    }\r\n\r\n    constructor(calcID: (espObj: I | C) => string) {\r\n        this._calcID = calcID;\r\n    }\r\n\r\n    has(espObj: I): boolean {\r\n        return this._calcID(espObj) in this._cache;\r\n    }\r\n\r\n    set(obj: C): C {\r\n        this._cache[this._calcID(obj)] = obj;\r\n        return obj;\r\n    }\r\n\r\n    get(espObj: I, factory: () => C): C {\r\n        const retVal = this._cache[this._calcID(espObj)];\r\n        if (!retVal) {\r\n            return this.set(factory());\r\n        }\r\n        return retVal;\r\n    }\r\n}\r\n","//  TODO switch to propper logger  ---\r\n\r\nexport enum Level {\r\n    debug,\r\n    info,\r\n    notice,\r\n    warning,\r\n    error,\r\n    critical,\r\n    alert,\r\n    emergency\r\n}\r\n\r\nexport class Logging {\r\n    log(level: Level, msg: string) {\r\n        const d = new Date();\r\n        const n = d.toISOString();\r\n        // tslint:disable-next-line:no-console\r\n        console.log(`${n} <${Level[level]}>:  ${msg}`);\r\n    }\r\n\r\n    debug(msg: string) {\r\n        this.log(Level.debug, msg);\r\n    }\r\n\r\n    info(msg: string) {\r\n        this.log(Level.info, msg);\r\n    }\r\n\r\n    notice(msg: string) {\r\n        this.log(Level.notice, msg);\r\n    }\r\n\r\n    warning(msg: string) {\r\n        this.log(Level.warning, msg);\r\n    }\r\n\r\n    error(msg: string) {\r\n        this.log(Level.error, msg);\r\n    }\r\n\r\n    critical(msg: string) {\r\n        this.log(Level.critical, msg);\r\n    }\r\n\r\n    alert(msg: string) {\r\n        this.log(Level.alert, msg);\r\n    }\r\n\r\n    emergency(msg: string) {\r\n        this.log(Level.emergency, msg);\r\n    }\r\n}\r\n\r\nexport let logger = new Logging();\r\n","import { StateObject } from \"../../collections/stateful\";\r\nimport { Service } from \"../services/WsWorkunits\";\r\n\r\nexport interface ResourceEx {\r\n    Wuid: string;\r\n    URL: string;\r\n    DisplayName: string;\r\n    DisplayPath: string;\r\n}\r\n\r\nexport class Resource extends StateObject<ResourceEx, ResourceEx> implements ResourceEx {\r\n    protected connection: Service;\r\n\r\n    get properties(): ResourceEx { return this.get(); }\r\n    get Wuid(): string { return this.get(\"Wuid\"); }\r\n    get URL(): string { return this.get(\"URL\"); }\r\n    get DisplayName(): string { return this.get(\"DisplayName\"); }\r\n    get DisplayPath(): string { return this.get(\"DisplayPath\"); }\r\n\r\n    constructor(connection: Service | string, wuid: string, url: string) {\r\n        super();\r\n        if (connection instanceof Service) {\r\n            this.connection = connection;\r\n        } else {\r\n            this.connection = new Service(connection);\r\n        }\r\n\r\n        const cleanedURL = url.split(\"\\\\\").join(\"/\");\r\n        const urlParts = cleanedURL.split(\"/\");\r\n        const matchStr = \"res/\" + wuid + \"/\";\r\n        let displayPath = \"\";\r\n        let displayName = \"\";\r\n\r\n        if (cleanedURL.indexOf(matchStr) === 0) {\r\n            displayPath = cleanedURL.substr(matchStr.length);\r\n            displayName = urlParts[urlParts.length - 1];\r\n        }\r\n\r\n        this.set({\r\n            Wuid: wuid,\r\n            URL: url,\r\n            DisplayName: displayName,\r\n            DisplayPath: displayPath\r\n        });\r\n    }\r\n}\r\n","import { Cache, StateObject } from \"../../collections/stateful\";\r\nimport { exists } from \"../../util/object\";\r\nimport { parseXSD, XSDSchema } from \"../../util/SAXParser\";\r\nimport { DFULogicalFile } from \"../services/WsDFU\";\r\nimport { ECLResult, ECLSchemas, Service, WUResultRequest, WUResultResponse } from \"../services/WsWorkunits\";\r\n\r\nexport interface ECLResultEx extends ECLResult {\r\n    Wuid: string;\r\n    ResultViews: any[];\r\n}\r\nexport class Result extends StateObject<ECLResultEx & DFULogicalFile, ECLResultEx | DFULogicalFile> implements ECLResultEx {\r\n    protected connection: Service;\r\n    protected xsdSchema: XSDSchema;\r\n\r\n    get properties(): ECLResult { return this.get(); }\r\n    get Wuid(): string { return this.get(\"Wuid\"); }\r\n    get Name(): string { return this.get(\"Name\"); }\r\n    get Sequence(): number { return this.get(\"Sequence\"); }\r\n    get Value(): string { return this.get(\"Value\"); }\r\n    get Link(): string { return this.get(\"Link\"); }\r\n    get FileName(): string { return this.get(\"FileName\"); }\r\n    get IsSupplied(): boolean { return this.get(\"IsSupplied\"); }\r\n    get ShowFileContent() { return this.get(\"ShowFileContent\"); }\r\n    get Total(): number { return this.get(\"Total\"); }\r\n    get ECLSchemas(): ECLSchemas { return this.get(\"ECLSchemas\"); }\r\n    get NodeGroup(): string { return this.get(\"NodeGroup\"); }\r\n    get ResultViews(): any[] { return this.get(\"ResultViews\"); }\r\n\r\n    constructor(connection: Service | string, wuid: string, eclResult: ECLResult, resultViews: any[]) {\r\n        super();\r\n        if (connection instanceof Service) {\r\n            this.connection = connection;\r\n        } else {\r\n            this.connection = new Service(connection);\r\n        }\r\n        this.set({\r\n            Wuid: wuid,\r\n            ResultViews: resultViews,\r\n            ...eclResult\r\n        });\r\n    }\r\n\r\n    isComplete() {\r\n        return this.Total !== -1;\r\n    }\r\n\r\n    fetchXMLSchema(): Promise<XSDSchema> {\r\n        if (this.xsdSchema) {\r\n            return Promise.resolve(this.xsdSchema);\r\n        }\r\n        return this.WUResult().then((response) => {\r\n            if (exists(\"Result.XmlSchema.xml\", response)) {\r\n                this.xsdSchema = parseXSD(response.Result.XmlSchema.xml);\r\n                return this.xsdSchema;\r\n            }\r\n            return this;\r\n        });\r\n    }\r\n\r\n    fetchResult(): Promise<any[]> {\r\n        return this.WUResult(0, -1, true).then((response) => {\r\n            if (exists(\"Result.Row\", response)) {\r\n                return response.Result.Row;\r\n            }\r\n            return [];\r\n        });\r\n    }\r\n\r\n    protected WUResult(start: number = 0, count: number = 1, suppressXmlSchema: boolean = false): Promise<WUResultResponse> {\r\n        const request: WUResultRequest = <WUResultRequest>{};\r\n        if (this.Wuid && this.Sequence !== undefined) {\r\n            request.Wuid = this.Wuid;\r\n            request.Sequence = this.Sequence;\r\n        } else if (this.Name && this.NodeGroup) {\r\n            request.LogicalName = this.Name;\r\n            request.Cluster = this.NodeGroup;\r\n        } else if (this.Name) {\r\n            request.LogicalName = this.Name;\r\n        }\r\n        request.Start = start;\r\n        request.Count = count;\r\n        request.SuppressXmlSchema = suppressXmlSchema;\r\n        return this.connection.WUResult(request).then((response) => {\r\n            return response;\r\n        });\r\n    }\r\n}\r\n\r\nexport class ResultCache extends Cache<ECLResult, Result> {\r\n    constructor() {\r\n        super((obj) => {\r\n            return Cache.hash([obj.Sequence, obj.Name, obj.FileName]);\r\n        });\r\n    }\r\n}\r\n","import { StateObject } from \"../../collections/stateful\";\r\nimport { ECLSourceFile, Service, } from \"../services/WsWorkunits\";\r\n\r\nexport interface ECLSourceFileEx extends ECLSourceFile {\r\n    Wuid: string;\r\n}\r\n\r\nexport class SourceFile extends StateObject<ECLSourceFileEx, ECLSourceFileEx> implements ECLSourceFileEx {\r\n    protected connection: Service;\r\n\r\n    get properties(): ECLSourceFile { return this.get(); }\r\n    get Wuid(): string { return this.get(\"Wuid\"); }\r\n    get FileCluster(): string { return this.get(\"FileCluster\"); }\r\n    get Name(): string { return this.get(\"Name\"); }\r\n    get Count(): number { return this.get(\"Count\"); }\r\n\r\n    constructor(connection: Service | string, wuid: string, eclSourceFile: ECLSourceFile) {\r\n        super();\r\n        if (connection instanceof Service) {\r\n            this.connection = connection;\r\n        } else {\r\n            this.connection = new Service(connection);\r\n        }\r\n\r\n        this.set({\r\n            Wuid: wuid,\r\n            ...eclSourceFile\r\n        });\r\n    }\r\n}\r\n","import { StateObject } from \"../../collections/stateful\";\r\nimport { espTime2Seconds } from \"../../util/esp\";\r\nimport { ECLTimer, Service } from \"../services/WsWorkunits\";\r\n\r\nexport interface ECLTimerEx extends ECLTimer {\r\n    Wuid: string;\r\n    Seconds: number;\r\n    HasSubGraphId: boolean;\r\n}\r\n\r\nexport class Timer extends StateObject<ECLTimerEx, ECLTimerEx> implements ECLTimerEx {\r\n    protected connection: Service;\r\n\r\n    get properties(): ECLTimer { return this.get(); }\r\n    get Wuid(): string { return this.get(\"Wuid\"); }\r\n    get Name(): string { return this.get(\"Name\"); }\r\n    get Value(): string { return this.get(\"Value\"); }\r\n    get Seconds(): number { return this.get(\"Seconds\"); }\r\n    get GraphName(): string { return this.get(\"GraphName\"); }\r\n    get SubGraphId(): number { return this.get(\"SubGraphId\"); }\r\n    get HasSubGraphId(): boolean { return this.get(\"HasSubGraphId\"); }\r\n    get count(): number { return this.get(\"count\"); }\r\n\r\n    constructor(connection: Service | string, wuid: string, eclTimer: ECLTimer) {\r\n        super();\r\n        if (connection instanceof Service) {\r\n            this.connection = connection;\r\n        } else {\r\n            this.connection = new Service(connection);\r\n        }\r\n\r\n        const secs = espTime2Seconds(eclTimer.Value);\r\n        this.set({\r\n            Wuid: wuid,\r\n            Seconds: Math.round(secs * 1000) / 1000,\r\n            HasSubGraphId: eclTimer.SubGraphId !== undefined,\r\n            XXX: true,\r\n            ...eclTimer\r\n        });\r\n    }\r\n}\r\n","import { Cache, IEvent, StateCallback, StateEvents, StateObject, StatePropCallback } from \"../../collections/stateful\";\r\nimport { logger } from \"../../util/Logging\";\r\nimport { IObserverHandle } from \"../../util/observer\";\r\nimport { PrimativeValueMap, XMLNode } from \"../../util/SAXParser\";\r\nimport { ESPExceptions } from \"../comms/transport\";\r\nimport { ActiveWorkunit } from \"../services/WsSMC\";\r\nimport * as WsTopology from \"../services/WsTopology\";\r\nimport * as WsWorkunits from \"../services/WsWorkunits\";\r\nimport { createXGMMLGraph, Graph, GraphCache, IECLDefintion, XGMMLGraph } from \"./Graph\";\r\nimport { Resource } from \"./Resource\";\r\nimport { Result, ResultCache } from \"./Result\";\r\nimport { SourceFile } from \"./SourceFile\";\r\nimport { Timer } from \"./Timer\";\r\n\r\nexport const WUStateID = WsWorkunits.WUStateID;\r\n\r\nexport class WorkunitCache extends Cache<{ Wuid: string }, Workunit> {\r\n    constructor() {\r\n        super((obj) => {\r\n            return obj.Wuid;\r\n        });\r\n    }\r\n}\r\nconst _workunits = new WorkunitCache();\r\n\r\nexport interface DebugState {\r\n    sequence: number;\r\n    state: string;\r\n    [key: string]: any;\r\n}\r\n\r\nexport interface IWorkunit {\r\n    ResultViews: any[];\r\n    HelpersCount: number;\r\n}\r\n\r\nexport interface IDebugWorkunit {\r\n    DebugState?: DebugState;\r\n}\r\n\r\nexport type WorkunitEvents = \"completed\" | StateEvents;\r\nexport type UWorkunitState = WsWorkunits.ECLWorkunit & WsWorkunits.Workunit & ActiveWorkunit & IWorkunit & IDebugWorkunit;\r\nexport type IWorkunitState = WsWorkunits.ECLWorkunit | WsWorkunits.Workunit | ActiveWorkunit | IWorkunit | IDebugWorkunit;\r\nexport class Workunit extends StateObject<UWorkunitState, IWorkunitState> implements WsWorkunits.Workunit {\r\n    connection: WsWorkunits.Service;\r\n    topologyConnection: WsTopology.Service;\r\n\r\n    private _debugMode: boolean = false;\r\n    private _debugAllGraph: any;\r\n    private _submitAction: WsWorkunits.WUAction;\r\n    private _monitorHandle: any;\r\n    private _monitorTickCount: number = 0;\r\n\r\n    //  Accessors  ---\r\n    get properties(): WsWorkunits.ECLWorkunit & WsWorkunits.Workunit { return this.get(); }\r\n    get Wuid(): string { return this.get(\"Wuid\"); }\r\n    get Owner(): string { return this.get(\"Owner\", \"\"); }\r\n    get Cluster(): string { return this.get(\"Cluster\", \"\"); }\r\n    get Jobname(): string { return this.get(\"Jobname\", \"\"); }\r\n    get Description(): string { return this.get(\"Description\", \"\"); }\r\n    get ActionEx(): string { return this.get(\"ActionEx\", \"\"); }\r\n    get StateID(): WsWorkunits.WUStateID { return this.get(\"StateID\", WsWorkunits.WUStateID.Unknown); }\r\n    get State(): string { return WsWorkunits.WUStateID[this.StateID]; }\r\n    get Protected(): boolean { return this.get(\"Protected\", false); }\r\n    get Exceptions(): WsWorkunits.Exceptions { return this.get(\"Exceptions\", { ECLException: [] }); }\r\n    get ResultViews(): any[] { return this.get(\"ResultViews\", []); }\r\n\r\n    private _resultCache = new ResultCache();\r\n    get ResultCount(): number { return this.get(\"ResultCount\", 0); }\r\n    get Results(): WsWorkunits.Results { return this.get(\"Results\", { ECLResult: [] }); }\r\n    get CResults(): Result[] {\r\n        return this.Results.ECLResult.map((eclResult) => {\r\n            return this._resultCache.get(eclResult, () => {\r\n                return new Result(this.connection, this.Wuid, eclResult, this.ResultViews);\r\n            });\r\n        });\r\n    }\r\n    get SequenceResults(): { [key: number]: Result } {\r\n        const retVal = {};\r\n        this.CResults.forEach((result) => {\r\n            retVal[result.Sequence] = result;\r\n        });\r\n        return retVal;\r\n    };\r\n    get Timers(): WsWorkunits.Timers { return this.get(\"Timers\", { ECLTimer: [] }); }\r\n    get CTimers(): Timer[] {\r\n        return this.Timers.ECLTimer.map((eclTimer) => {\r\n            return new Timer(this.connection, this.Wuid, eclTimer);\r\n        });\r\n    }\r\n\r\n    private _graphCache = new GraphCache();\r\n    get GraphCount(): number { return this.get(\"GraphCount\", 0); }\r\n    get Graphs(): WsWorkunits.Graphs { return this.get(\"Graphs\", { ECLGraph: [] }); }\r\n    get CGraphs(): Graph[] {\r\n        return this.Graphs.ECLGraph.map((eclGraph) => {\r\n            return this._graphCache.get(eclGraph, () => {\r\n                return new Graph(this.connection, this.Wuid, eclGraph, this.CTimers);\r\n            });\r\n        });\r\n    }\r\n    get ThorLogList(): WsWorkunits.ThorLogList { return this.get(\"ThorLogList\"); }\r\n    get ResourceURLCount(): number { return this.get(\"ResourceURLCount\", 0); }\r\n    get ResourceURLs(): WsWorkunits.ResourceURLs { return this.get(\"ResourceURLs\", { URL: [] }); }\r\n    get CResourceURLs(): Resource[] {\r\n        return this.ResourceURLs.URL.map((url) => {\r\n            return new Resource(this.connection, this.Wuid, url);\r\n        });\r\n    }\r\n    get TotalClusterTime(): string { return this.get(\"TotalClusterTime\", \"\"); }\r\n    get DateTimeScheduled(): Date { return this.get(\"DateTimeScheduled\"); }\r\n    get IsPausing(): boolean { return this.get(\"IsPausing\"); }\r\n    get ThorLCR(): boolean { return this.get(\"ThorLCR\"); }\r\n    get ApplicationValues(): WsWorkunits.ApplicationValues { return this.get(\"ApplicationValues\", { ApplicationValue: [] }); }\r\n    get HasArchiveQuery(): boolean { return this.get(\"HasArchiveQuery\"); }\r\n    get StateEx(): string { return this.get(\"StateEx\"); }\r\n    get PriorityClass(): number { return this.get(\"PriorityClass\"); }\r\n    get PriorityLevel(): number { return this.get(\"PriorityLevel\"); }\r\n    get Snapshot(): string { return this.get(\"Snapshot\"); }\r\n    get ResultLimit(): number { return this.get(\"ResultLimit\"); }\r\n    get EventSchedule(): number { return this.get(\"EventSchedule\"); }\r\n    get HaveSubGraphTimings(): boolean { return this.get(\"HaveSubGraphTimings\"); }\r\n    get Query(): WsWorkunits.Query { return this.get(\"Query\"); }\r\n    get HelpersCount(): number { return this.get(\"HelpersCount\", 0); }\r\n    get Helpers(): WsWorkunits.Helpers { return this.get(\"Helpers\", { ECLHelpFile: [] }); }\r\n    get DebugValues(): WsWorkunits.DebugValues { return this.get(\"DebugValues\"); }\r\n    get AllowedClusters(): WsWorkunits.AllowedClusters { return this.get(\"AllowedClusters\"); }\r\n    get ErrorCount(): number { return this.get(\"ErrorCount\", 0); }\r\n    get WarningCount(): number { return this.get(\"WarningCount\", 0); }\r\n    get InfoCount(): number { return this.get(\"InfoCount\", 0); }\r\n    get AlertCount(): number { return this.get(\"AlertCount\", 0); }\r\n    get SourceFileCount(): number { return this.get(\"SourceFileCount\", 0); }\r\n    get SourceFiles(): WsWorkunits.SourceFiles { return this.get(\"SourceFiles\", { ECLSourceFile: [] }); }\r\n    get CSourceFiles(): SourceFile[] {\r\n        return this.SourceFiles.ECLSourceFile.map((eclSourceFile) => {\r\n            return new SourceFile(this.connection, this.Wuid, eclSourceFile);\r\n        });\r\n    }\r\n    get VariableCount(): number { return this.get(\"VariableCount\", 0); }\r\n    get Variables(): any { return this.get(\"Variables\", { ECLVariable: [] }); }\r\n    get TimerCount(): number { return this.get(\"TimerCount\", 0); }\r\n    get HasDebugValue(): boolean { return this.get(\"HasDebugValue\"); }\r\n    get ApplicationValueCount(): number { return this.get(\"ApplicationValueCount\", 0); }\r\n    get XmlParams(): string { return this.get(\"XmlParams\"); }\r\n    get AccessFlag(): number { return this.get(\"AccessFlag\"); }\r\n    get ClusterFlag(): number { return this.get(\"ClusterFlag\"); }\r\n    get ResultViewCount(): number { return this.get(\"ResultViewCount\", 0); }\r\n    get DebugValueCount(): number { return this.get(\"DebugValueCount\", 0); }\r\n    get WorkflowCount(): number { return this.get(\"WorkflowCount\", 0); }\r\n    get Archived(): boolean { return this.get(\"Archived\"); }\r\n    get DebugState(): DebugState { return this.get(\"DebugState\", {} as DebugState); }\r\n\r\n    //  Factories  ---\r\n    static create(href: string): Promise<Workunit>;\r\n    static create(connection: WsWorkunits.Service | string, topologyConnection?: WsTopology.Service | string): Promise<Workunit>;\r\n    static create(connection: WsWorkunits.Service | string, topologyConnection?: WsTopology.Service | string): Promise<Workunit> {\r\n        const retVal: Workunit = new Workunit(connection, topologyConnection);\r\n        return retVal.connection.WUCreate().then((response) => {\r\n            _workunits.set(retVal);\r\n            retVal.set(response.Workunit);\r\n            return retVal;\r\n        });\r\n    }\r\n\r\n    static attach(href: string, wuid: string, state?: WsWorkunits.ECLWorkunit | WsWorkunits.Workunit): Workunit;\r\n    static attach(connection: WsWorkunits.Service, topologyConnection: WsTopology.Service, wuid: string, state?: WsWorkunits.ECLWorkunit | WsWorkunits.Workunit): Workunit;\r\n    static attach(arg0: string | WsWorkunits.Service, arg1: string | WsTopology.Service, arg2?: WsWorkunits.ECLWorkunit | WsWorkunits.Workunit | string, state?: WsWorkunits.ECLWorkunit | WsWorkunits.Workunit): Workunit {\r\n        let retVal: Workunit;\r\n        if (arg0 instanceof WsWorkunits.Service && arg1 instanceof WsTopology.Service) {\r\n            retVal = _workunits.get({ Wuid: arg2 as string }, () => {\r\n                return new Workunit(arg0, arg1, arg2 as string);\r\n            });\r\n        } else {\r\n            retVal = _workunits.get({ Wuid: arg1 as string }, () => {\r\n                return new Workunit(arg0 as string, arg1 as string);\r\n            });\r\n            state = arg2 as WsWorkunits.ECLWorkunit | WsWorkunits.Workunit;\r\n        }\r\n        if (state) {\r\n            retVal.set(state);\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    static exists(wuid: string): boolean {\r\n        return _workunits.has({ Wuid: wuid });\r\n    }\r\n\r\n    //  ---  ---  ---\r\n    protected constructor(connection: WsWorkunits.Service | string, topologyConnection: WsTopology.Service | string, wuid?: string) {\r\n        super();\r\n        if (connection instanceof WsWorkunits.Service) {\r\n            this.connection = connection;\r\n        } else {\r\n            this.connection = new WsWorkunits.Service(connection);\r\n        }\r\n        if (topologyConnection instanceof WsTopology.Service) {\r\n            this.topologyConnection = topologyConnection;\r\n        } else {\r\n            this.topologyConnection = new WsTopology.Service(topologyConnection || connection as string);\r\n        }\r\n        this.clearState(wuid);\r\n    }\r\n\r\n    clearState(wuid: string) {\r\n        this.clear({\r\n            Wuid: wuid,\r\n            StateID: WUStateID.Unknown\r\n        });\r\n        this._monitorTickCount = 0;\r\n    }\r\n\r\n    update(request: Partial<WsWorkunits.WUUpdateRequest>, appData?: any, debugData?: any): Promise<Workunit> {\r\n        return this.connection.WUUpdate({\r\n            ...request, ...{\r\n                Wuid: this.Wuid,\r\n                StateOrig: this.State,\r\n                JobnameOrig: this.Jobname,\r\n                DescriptionOrig: this.Description,\r\n                ProtectedOrig: this.Protected,\r\n                ClusterOrig: this.Cluster,\r\n                ApplicationValues: appData,\r\n                DebugValues: debugData\r\n            }\r\n        }).then((response) => {\r\n            this.set(response.Workunit);\r\n            return this;\r\n        });\r\n    }\r\n\r\n    submit(_cluster?: string, action: WsWorkunits.WUAction = WsWorkunits.WUAction.Run, resultLimit?: number): Promise<Workunit> {\r\n        let clusterPromise;\r\n        if (_cluster !== void 0) {\r\n            clusterPromise = Promise.resolve(_cluster);\r\n        } else {\r\n            clusterPromise = this.topologyConnection.DefaultTpLogicalClusterQuery().then((response) => {\r\n                return response.Name;\r\n            });\r\n        }\r\n\r\n        this._debugMode = false;\r\n        if (action === WsWorkunits.WUAction.Debug) {\r\n            action = WsWorkunits.WUAction.Run;\r\n            this._debugMode = true;\r\n        }\r\n\r\n        return clusterPromise.then((cluster) => {\r\n            return this.connection.WUUpdate({\r\n                Wuid: this.Wuid,\r\n                Action: action,\r\n                ResultLimit: resultLimit\r\n            }, {}, { Debug: this._debugMode }).then((response) => {\r\n                this.set(response.Workunit);\r\n                this._submitAction = action;\r\n                return this.connection.WUSubmit({ Wuid: this.Wuid, Cluster: cluster }).then(() => {\r\n                    return this;\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    isComplete(): boolean {\r\n        switch (this.StateID) {\r\n            case WUStateID.Compiled:\r\n                return this.ActionEx === \"compile\" || this._submitAction === WsWorkunits.WUAction.Compile;\r\n            case WUStateID.Completed:\r\n            case WUStateID.Failed:\r\n            case WUStateID.Aborted:\r\n            case WUStateID.NotFound:\r\n                return true;\r\n            default:\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isFailed() {\r\n        switch (this.StateID) {\r\n            case WUStateID.Failed:\r\n                return true;\r\n            default:\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isDeleted() {\r\n        switch (this.StateID) {\r\n            case WUStateID.NotFound:\r\n                return true;\r\n            default:\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isDebugging() {\r\n        switch (this.StateID) {\r\n            case WUStateID.DebugPaused:\r\n            case WUStateID.DebugRunning:\r\n                return true;\r\n            default:\r\n        }\r\n        return false;\r\n    }\r\n\r\n    isRunning(): boolean {\r\n        switch (this.StateID) {\r\n            case WUStateID.Compiled:\r\n            case WUStateID.Running:\r\n            case WUStateID.Aborting:\r\n            case WUStateID.Blocked:\r\n            case WUStateID.DebugPaused:\r\n            case WUStateID.DebugRunning:\r\n                return true;\r\n            default:\r\n        }\r\n        return false;\r\n    }\r\n\r\n    setToFailed() {\r\n        return this.WUAction(\"SetToFailed\");\r\n    }\r\n\r\n    pause() {\r\n        return this.WUAction(\"Pause\");\r\n    }\r\n\r\n    pauseNow() {\r\n        return this.WUAction(\"PauseNow\");\r\n    }\r\n\r\n    resume() {\r\n        return this.WUAction(\"Resume\");\r\n    }\r\n\r\n    abort() {\r\n        return this.WUAction(\"Abort\");\r\n    }\r\n\r\n    delete() {\r\n        return this.WUAction(\"Delete\");\r\n    }\r\n\r\n    restore() {\r\n        return this.WUAction(\"Restore\");\r\n    }\r\n\r\n    deschedule() {\r\n        return this.WUAction(\"Deschedule\");\r\n    }\r\n\r\n    reschedule() {\r\n        return this.WUAction(\"Reschedule\");\r\n    }\r\n\r\n    refresh(full: boolean = false): Promise<Workunit> {\r\n        const refreshPromise: Promise<WsWorkunits.WUInfoResponse | WsWorkunits.WUQueryResponse> = full ? this.WUInfo() : this.WUQuery();\r\n        const debugPromise = this.debugStatus();\r\n        return Promise.all([\r\n            refreshPromise,\r\n            debugPromise\r\n        ]).then(() => {\r\n            return this;\r\n        });\r\n    }\r\n\r\n    fetchResults(): Promise<Result[]> {\r\n        return this.WUInfo({ IncludeResults: true }).then(() => {\r\n            return this.CResults;\r\n        });\r\n    };\r\n\r\n    //  Monitoring  ---\r\n    protected _monitor(): void {\r\n        if (this._monitorHandle || this.isComplete()) {\r\n            this._monitorTickCount = 0;\r\n            return;\r\n        }\r\n\r\n        this._monitorHandle = setTimeout(() => {\r\n            const refreshPromise: Promise<any> = this.hasEventListener() ? this.refresh(true) : Promise.resolve(null);\r\n            refreshPromise.then(() => {\r\n                this._monitor();\r\n            });\r\n            delete this._monitorHandle;\r\n        }, this._monitorTimeoutDuraction());\r\n    }\r\n\r\n    private _monitorTimeoutDuraction(): number {\r\n        ++this._monitorTickCount;\r\n        if (this._monitorTickCount <= 1) {\r\n            return 0;\r\n        } else if (this._monitorTickCount <= 3) {\r\n            return 500;\r\n        } else if (this._monitorTickCount <= 10) {\r\n            return 1000;\r\n        } else if (this._monitorTickCount <= 20) {\r\n            return 3000;\r\n        } else if (this._monitorTickCount <= 30) {\r\n            return 5000;\r\n        }\r\n        return 10000;\r\n    }\r\n\r\n    //  Events  ---\r\n    on(eventID: WorkunitEvents, propIDorCallback: StateCallback | keyof UWorkunitState, callback?: StatePropCallback): Workunit {\r\n        if (this.isCallback(propIDorCallback)) {\r\n            switch (eventID) {\r\n                case \"completed\":\r\n                    super.on(\"propChanged\", \"StateID\", (changeInfo: IEvent) => {\r\n                        if (this.isComplete()) {\r\n                            propIDorCallback([changeInfo]);\r\n                        }\r\n                    });\r\n                    break;\r\n                case \"changed\":\r\n                    super.on(eventID, propIDorCallback);\r\n                    break;\r\n                default:\r\n            }\r\n        } else {\r\n            switch (eventID) {\r\n                case \"changed\":\r\n                    super.on(eventID, propIDorCallback, callback);\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n        this._monitor();\r\n        return this;\r\n    }\r\n\r\n    watch(callback: StateCallback, triggerChange: boolean = true): IObserverHandle {\r\n        if (typeof callback !== \"function\") {\r\n            throw new Error(\"Invalid Callback\");\r\n        }\r\n        if (triggerChange) {\r\n            setTimeout(() => {\r\n                const props: any = this.properties;\r\n                const changes: IEvent[] = [];\r\n                for (const key in props) {\r\n                    if (props.hasOwnProperty(props)) {\r\n                        changes.push({ id: key, newValue: props[key], oldValue: undefined });\r\n                    }\r\n                }\r\n                callback(changes);\r\n            }, 0);\r\n        }\r\n        const retVal = super.on(\"changed\", callback);\r\n        this._monitor();\r\n        return retVal;\r\n    }\r\n\r\n    watchUntilComplete(callback?: StateCallback): Promise<this> {\r\n        return new Promise((resolve, _) => {\r\n            const watchHandle = this.watch((changes) => {\r\n                if (callback) {\r\n                    callback(changes);\r\n                }\r\n                if (this.isComplete()) {\r\n                    watchHandle.release();\r\n                    resolve(this);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    watchUntilRunning(callback?: StateCallback): Promise<this> {\r\n        return new Promise((resolve, _) => {\r\n            const watchHandle = this.watch((changes) => {\r\n                if (callback) {\r\n                    callback(changes);\r\n                }\r\n                if (this.isComplete() || this.isRunning()) {\r\n                    watchHandle.release();\r\n                    resolve(this);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    //  WsWorkunits passthroughs  ---\r\n    protected WUQuery(_request: Partial<WsWorkunits.WUQueryRequest> = {}): Promise<WsWorkunits.WUQueryResponse> {\r\n        return this.connection.WUQuery({ ..._request, Wuid: this.Wuid }).then((response) => {\r\n            this.set(response.Workunits.ECLWorkunit[0]);\r\n            return response;\r\n        }).catch((e: ESPExceptions) => {\r\n            //  deleted  ---\r\n            const wuMissing = e.Exception.some((exception) => {\r\n                if (exception.Code === 20081) {\r\n                    this.clearState(this.Wuid);\r\n                    this.set(\"StateID\", WUStateID.NotFound);\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (!wuMissing) {\r\n                logger.warning(\"Unexpected exception:  \");\r\n                throw e;\r\n            }\r\n            return {};\r\n        });\r\n    }\r\n\r\n    protected WUCreate() {\r\n        return this.connection.WUCreate().then((response) => {\r\n            this.set(response.Workunit);\r\n            _workunits.set(this);\r\n            return response;\r\n        });\r\n    }\r\n\r\n    protected WUInfo(_request: Partial<WsWorkunits.WUInfoRequest> = {}): Promise<WsWorkunits.WUInfoResponse> {\r\n        const includeResults = _request.IncludeResults || _request.IncludeResultsViewNames;\r\n        return this.connection.WUInfo({\r\n            ..._request, Wuid: this.Wuid,\r\n            IncludeResults: includeResults,\r\n            IncludeResultsViewNames: includeResults,\r\n            SuppressResultSchemas: false\r\n        }).then((response) => {\r\n            if (response.Workunit.ResourceURLCount) {\r\n                response.Workunit.ResourceURLCount = response.Workunit.ResourceURLCount - 1;\r\n            }\r\n            if (response.Workunit.ResourceURLs && response.Workunit.ResourceURLs.URL) {\r\n                response.Workunit.ResourceURLs.URL = response.Workunit.ResourceURLs.URL.filter((_, idx) => {\r\n                    return idx > 0;\r\n                });\r\n            }\r\n            this.set(response.Workunit);\r\n            this.set({\r\n                ResultViews: includeResults ? response.ResultViews : [],\r\n                HelpersCount: response.Workunit.Helpers && response.Workunit.Helpers.ECLHelpFile ? response.Workunit.Helpers.ECLHelpFile.length : 0\r\n            });\r\n            return response;\r\n        }).catch((e: ESPExceptions) => {\r\n            //  deleted  ---\r\n            const wuMissing = e.Exception.some((exception) => {\r\n                if (exception.Code === 20080) {\r\n                    this.clearState(this.Wuid);\r\n                    this.set(\"StateID\", WUStateID.NotFound);\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            if (!wuMissing) {\r\n                logger.warning(\"Unexpected exception:  \");\r\n                throw e;\r\n            }\r\n            return {};\r\n        });\r\n    }\r\n\r\n    protected WUAction(actionType: WsWorkunits.WUActionType): Promise<WsWorkunits.WUActionResponse> {\r\n        return this.connection.WUAction({\r\n            Wuids: [this.Wuid],\r\n            WUActionType: actionType\r\n        }).then((response) => {\r\n            return this.refresh().then(() => {\r\n                this._monitor();\r\n                return response;\r\n            });\r\n        });\r\n    }\r\n\r\n    protected WUResubmit(clone: boolean, resetWorkflow: boolean): Promise<WsWorkunits.WUResubmitResponse> {\r\n        return this.connection.WUResubmit({\r\n            Wuids: [this.Wuid],\r\n            CloneWorkunit: clone,\r\n            ResetWorkflow: resetWorkflow\r\n        }).then((response) => {\r\n            this.clearState(this.Wuid);\r\n            return this.refresh().then(() => {\r\n                this._monitor();\r\n                return response;\r\n            });\r\n        });\r\n    }\r\n\r\n    protected WUCDebug(command: string, opts: Object = {}): Promise<XMLNode> {\r\n        let optsStr = \"\";\r\n        for (const key in opts) {\r\n            if (opts.hasOwnProperty(key)) {\r\n                optsStr += ` ${key}='${opts[key]}'`;\r\n            }\r\n        }\r\n        return this.connection.WUCDebug({\r\n            Wuid: this.Wuid,\r\n            Command: `<debug:${command} uid='${this.Wuid}'${optsStr}/>`\r\n        }).then((response) => {\r\n            return response;\r\n        });\r\n    }\r\n\r\n    debug(command: string, opts?: Object): Promise<XMLNode> {\r\n        if (!this.isDebugging()) {\r\n            return Promise.resolve(null);\r\n        }\r\n        return this.WUCDebug(command, opts).then((response: XMLNode) => {\r\n            return response.children.filter((xmlNode) => {\r\n                return xmlNode.name === command;\r\n            })[0];\r\n        }).catch((_) => {\r\n            // console.log(e);\r\n            return Promise.resolve(null);\r\n        });\r\n    }\r\n\r\n    debugStatus(): Promise<XMLNode> {\r\n        if (!this.isDebugging()) {\r\n            return Promise.resolve<any>({\r\n                DebugState: { state: \"unknown\" }\r\n            });\r\n        }\r\n        return this.debug(\"status\").then((response) => {\r\n            response = response || new XMLNode(\"null\");\r\n            const debugState = { ...this.DebugState, ...response.attributes };\r\n            this.set({\r\n                DebugState: debugState\r\n            });\r\n            return response;\r\n        });\r\n    }\r\n\r\n    debugContinue(mode = \"\"): Promise<XMLNode> {\r\n        return this.debug(\"continue\", {\r\n            mode\r\n        });\r\n    }\r\n\r\n    debugStep(mode): Promise<XMLNode> {\r\n        return this.debug(\"step\", {\r\n            mode\r\n        });\r\n    }\r\n\r\n    debugPause(): Promise<XMLNode> {\r\n        return this.debug(\"interrupt\");\r\n    }\r\n\r\n    debugQuit(): Promise<XMLNode> {\r\n        return this.debug(\"quit\");\r\n    }\r\n\r\n    debugDeleteAllBreakpoints(): Promise<XMLNode> {\r\n        return this.debug(\"delete\", {\r\n            idx: 0\r\n        });\r\n    }\r\n\r\n    protected debugBreakpointResponseParser(rootNode) {\r\n        return rootNode.children.map((childNode) => {\r\n            if (childNode.name === \"break\") {\r\n                return childNode.attributes;\r\n            }\r\n        });\r\n    }\r\n\r\n    debugBreakpointAdd(id, mode, action): Promise<XMLNode> {\r\n        return this.debug(\"breakpoint\", {\r\n            id,\r\n            mode,\r\n            action\r\n        }).then((rootNode) => this.debugBreakpointResponseParser(rootNode));\r\n    }\r\n\r\n    debugBreakpointList(): Promise<any[]> {\r\n        return this.debug(\"list\").then((rootNode) => {\r\n            return this.debugBreakpointResponseParser(rootNode);\r\n        });\r\n    }\r\n\r\n    debugGraph(): Promise<XGMMLGraph> {\r\n        if (this._debugAllGraph && this.DebugState[\"_prevGraphSequenceNum\"] === this.DebugState[\"graphSequenceNum\"]) {\r\n            return Promise.resolve(this._debugAllGraph);\r\n        }\r\n        return this.debug(\"graph\", { name: \"all\" }).then((response) => {\r\n            this.DebugState[\"_prevGraphSequenceNum\"] = this.DebugState[\"graphSequenceNum\"];\r\n            this._debugAllGraph = createXGMMLGraph(this.Wuid, response);\r\n            return this._debugAllGraph;\r\n        });\r\n    }\r\n\r\n    debugBreakpointValid(path): Promise<IECLDefintion[]> {\r\n        return this.debugGraph().then((graph) => {\r\n            return graph.breakpointLocations(path);\r\n        });\r\n    }\r\n\r\n    debugPrint(edgeID: string, startRow: number = 0, numRows: number = 10): Promise<PrimativeValueMap[]> {\r\n        return this.debug(\"print\", {\r\n            edgeID,\r\n            startRow,\r\n            numRows\r\n        }).then((response: XMLNode) => {\r\n            return response.children.map((rowNode) => {\r\n                const retVal: PrimativeValueMap = {};\r\n                rowNode.children.forEach((cellNode) => {\r\n                    retVal[cellNode.name] = cellNode.content;\r\n                });\r\n                return retVal;\r\n            });\r\n        });\r\n    }\r\n}\r\n","export const version = \"0.0.1\";\r\n\r\nexport { JSONPTransport, XHRGetTransport, XHRPostTransport, createTransport, setTransportFactory } from \"./comms/index\";\r\n\r\nexport { Service as WsWorkunits, WUAction } from \"./esp/services/WsWorkunits\";\r\nexport { Service as WsTopology } from \"./esp/services/WsTopology\";\r\nexport { Service as WsSMC } from \"./esp/services/WsSMC\";\r\nexport { Service as WsDFU } from \"./esp/services/WsDFU\";\r\n\r\nexport { Workunit } from \"./esp/ecl/Workunit\";\r\nexport { Result } from \"./esp/ecl/Result\";\r\nexport { SourceFile } from \"./esp/ecl/SourceFile\";\r\nexport { Resource } from \"./esp/ecl/Resource\";\r\nexport { Timer } from \"./esp/ecl/Timer\";\r\nexport { XGMMLGraph, GraphItem } from \"./esp/ecl/Graph\";\r\n\r\nexport { IObserverHandle } from \"./util/observer\";\r\nexport { espTime2Seconds } from \"./util/esp\";\r\n","// DOM Parser polyfill  ---\r\nimport { DOMParser } from \"xmldom\";\r\nimport { root } from \"./util/runtime\";\r\nroot.DOMParser = DOMParser;\r\n\r\n//  XHR polyfill  ---\r\nimport * as nodeRequest from \"request\";\r\nimport { initNodeRequest } from \"./comms/xhr\";\r\ninitNodeRequest(nodeRequest);\r\n\r\n//  Alternative XHR polyfill   ---\r\n//  import { request as d3Request } from \"d3-request\";\r\n//  initD3Request(d3Request);\r\n\r\nexport * from \"./index\";\r\n"],"names":["origString","searchString","position","subjectString","toString","isFinite","Math","floor","length","lastIndex","lastIndexOf","request","_nodeRequest","newFunc","retVal","createTransport","xml","saxParser","SAXStackParser","parse","root","XSDParser","schema","arg","Object","prototype","call","hash","len","text","i","charCodeAt","o","seen","keys","sort","reduce","input","key","foldValue","value","fold","undefined","indexOf","push","foldObject","pad","prop","obj","_a","split","_i","item","hasOwnProperty","inner","node","callback","stack","name","attributes","children","forEach","childNode","walkXmlJson","pop","nodes","id","graphs","graph","XGMMLGraph","tag","_stack","top","subgraph","Subgraph","flattenAtt","allSubgraphs","vertex","Vertex","allVertices","edge","Edge","allEdges","source","sourceID","target","targetID","outEdges","inEdges","e","duration","isNaN","parseFloat","nsIndex","substr","msIndex","sIndex","dayTimeParts","days","time","secs","timeParts","reverse","j","pow","Function","baseUrl","this","opts","Transport","_","arguments","_opts","str","encodeURIComponent","join","body","JSON","substring","endsWith","args","stripSlashes","map","_this","_d3Request","verb","userID","password","rejectUnauthorized","_super","tslib_1.__extends","XHRTransport","action","responseType","Promise","resolve","reject","options","method","uri","joinUrl","auth","user","pass","sendImmediately","username","serialize","headers","X-Requested-With","Content-Type","err","resp","Error","statusCode","deserialize","xhr","header","send","req","status","responseText","nodeRequestSend","d3Send","timeout","JSONPTransport","window","callbackName","document","removeChild","script","respondedTimeout","round","random","response","doCallback","createElement","url","src","appendChild","progress","setInterval","clearInterval","XHRPostTransport","Stack","XMLNode","val","content","child","startXMLNode","nodeName","attribute","nodeValue","childNodes","nodeType","TEXT_NODE","characters","walkDoc","endXMLNode","domParser","DOMParser","doc","parseFromString","startDocument","endDocument","newNode","depth","appendAttribute","appendContent","XSDNode","XSDXMLNode","type","row","splice","fix","XSDSimpleType","_restricition","_maxLength","maxLength","XSDSchema","numStr","underbarPos","length_1","charAt","parseInt","xsdXMLNode","xsdStack","append","simpleType","simpleTypes","exceptions","Source","Exception","transport","service","version","_transport","_service","_version","ESPTransport","arrayName","isArray","_request","ver_","serviceAction","then","Exceptions","ESPExceptions","Code","Message","WUStateID","WUAction","Service","Wuid","TruncateEclTo64k","IncludeExceptions","IncludeGraphs","IncludeSourceFiles","IncludeResults","IncludeResultsViewNames","IncludeVariables","IncludeTimers","IncludeDebugValues","IncludeApplicationValues","IncludeWorkflows","IncludeXmlSchemas","IncludeResourceURLs","SuppressResultSchemas","count","appValues","debugValues","objToESPArray","toESPStringArray","ActionType","WUActionType","xml2json","Result","TpLogicalClusterQuery","default","firstHThor","first","TpLogicalClusters","TpLogicalCluster","some","idx","Type","eventTarget","eventID","ObserverHandle","removeObserver","release","events","_knownEvents","Observable","eventObservers","_eventObservers","eventObservers_1","observer","_eventID","_hasObserver","StateObject","newVals","_espState","_espStateCache","set","defValue","has","qualifiedID","exists","keyOrNewVals","newVal","batchMode","setSingle","setAll","oldCacheVal","newCacheVal","hashSum","oldVal","changedInfo","oldValue","newValue","_events","dispatchEvent","changed","changed_1","changeInfo","propIDOrCallback","isCallback","addObserver","hasObserver","calcID","_calcID","Cache","espObj","_cache","factory","Level","Logging","level","msg","d","Date","n","toISOString","console","log","debug","info","notice","warning","error","critical","alert","emergency","logger","connection","wuid","eclGraph","eclTimers","eclTimers_1","eclTimer","GraphName","Name","HasSubGraphId","Seconds","Time","Graph","get","ATTR_DEFINITION","parent","attrs","GraphItem","constructor","match","exec","_file","_row","_col","replace","file","line","column","addSubgraph","subgraphsMap","subgraphs","verticesMap","vertices","edgesMap","edges","backwards","hasECLDefinition","getECLDefinition","getNearestDefinition","label","addVertex","path","definition","l","r","addEdge","cleanedURL","urlParts","matchStr","displayPath","displayName","URL","DisplayName","DisplayPath","Resource","eclResult","resultViews","ResultViews","Total","xsdSchema","WUResult","parseXSD","XmlSchema","Row","start","suppressXmlSchema","Sequence","NodeGroup","LogicalName","Cluster","Start","Count","SuppressXmlSchema","FileName","eclSourceFile","SourceFile","espTime2Seconds","Value","SubGraphId","XXX","Timer","WsWorkunits.WUStateID","_workunits","WorkunitCache","topologyConnection","ResultCache","GraphCache","WsWorkunits.Service","WsTopology.Service","clearState","Workunit","Unknown","StateID","ECLException","ECLResult","Results","_resultCache","CResults","result","ECLTimer","Timers","ECLGraph","Graphs","_graphCache","CTimers","ResourceURLs","ApplicationValue","ECLHelpFile","ECLSourceFile","SourceFiles","ECLVariable","WUCreate","arg0","arg1","arg2","state","clear","_monitorTickCount","appData","debugData","WUUpdate","StateOrig","State","JobnameOrig","Jobname","DescriptionOrig","Description","ProtectedOrig","Protected","ClusterOrig","ApplicationValues","DebugValues","_cluster","resultLimit","WsWorkunits.WUAction","Run","clusterPromise","DefaultTpLogicalClusterQuery","_debugMode","Debug","cluster","Action","ResultLimit","_submitAction","WUSubmit","Compiled","ActionEx","Compile","Completed","Failed","Aborted","NotFound","DebugPaused","DebugRunning","Running","Aborting","Blocked","full","refreshPromise","WUInfo","WUQuery","debugPromise","debugStatus","all","_monitorHandle","isComplete","setTimeout","hasEventListener","refresh","_monitor","_monitorTimeoutDuraction","propIDorCallback","on","triggerChange","props","properties","changes","watchHandle","watch","isRunning","Workunits","ECLWorkunit","catch","exception","includeResults","ResourceURLCount","filter","HelpersCount","Helpers","actionType","Wuids","clone","resetWorkflow","WUResubmit","CloneWorkunit","ResetWorkflow","command","optsStr","WUCDebug","Command","isDebugging","xmlNode","debugState","DebugState","mode","rootNode","debugBreakpointResponseParser","_debugAllGraph","createXGMMLGraph","debugGraph","breakpointLocations","edgeID","startRow","numRows","rowNode","cellNode","initNodeRequest","nodeRequest"],"mappings":"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"}